/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

/*
 * Changes for GemFireXD distributed data platform.
 *
 * Portions Copyright (c) 2010-2015 Pivotal Software, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License. You
 * may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License. See accompanying
 * LICENSE file.
 */
/*
 * Changes for SnappyData data platform.
 *
 * Portions Copyright (c) 2016 SnappyData, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License. You
 * may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License. See accompanying
 * LICENSE file.
 */

#ifndef SNAPPYDATA_STRUCT_COLUMNVALUE_H
#define SNAPPYDATA_STRUCT_COLUMNVALUE_H


extern "C" {
#include <string.h>
}

#include "snappydata_struct_Decimal.h"
#include "snappydata_struct_Timestamp.h"
#include "snappydata_struct_JSONValue.h"
#include "snappydata_struct_JSONObject.h"
#include "snappydata_struct_BlobChunk.h"
#include "snappydata_struct_ClobChunk.h"
#include "snappydata_struct_ServiceMetaData.h"
#include "snappydata_struct_ServiceMetaDataArgs.h"
#include "snappydata_struct_OpenConnectionArgs.h"
#include "snappydata_struct_ConnectionProperties.h"
#include "snappydata_struct_HostAddress.h"
#include "snappydata_struct_SnappyExceptionData.h"
#include "snappydata_struct_StatementAttrs.h"
#include "snappydata_struct_DateTime.h"

#include "snappydata_types.h"

#include <vector>
#include <map>

namespace io { namespace snappydata { namespace thrift {

class ColumnValue {
private:

  union {
    bool bool_val;
    int8_t byte_val;
    int16_t i16_val;
    int32_t i32_val;
    int64_t i64_val;
    float float_val;
    double double_val;
    std::string* string_binary_java_val;
    Decimal* decimal_val;
    int64_t date_time_epoch_val;
    struct __ts {
      int64_t epochTime;
      int32_t nanos;

      bool operator==(const __ts other) const {
        return epochTime == other.epochTime && nanos == other.nanos;
      }
    } timestamp_val;
    BlobChunk* blob_val;
    ClobChunk* clob_val;
    std::vector<ColumnValue>* array_val;
    std::map<ColumnValue, ColumnValue>* map_val;
    std::vector<ColumnValue>* struct_val;
    bool null_val;
    JSONObject* json_val;
  } m_uval;

  SnappyType::type m_type;

  /**
   * This is required to be invoked after clearValue() has been invoked
   * (or in constructor where it is not needed)
   */
  void copyFields(const ColumnValue& other);

public:

  ColumnValue() : m_type(SnappyType::OTHER) {
  }

  void clearValue() throw();

  inline ColumnValue(const ColumnValue& other) {
    if (other.m_type == SnappyType::OTHER) {
      m_type = SnappyType::OTHER;
      return;
    }
    copyFields(other);
  }

  inline ColumnValue& operator=(const ColumnValue& other) {
    if (other.m_type == SnappyType::OTHER) {
      if (m_type == SnappyType::OTHER) {
        return *this;
      }
      m_type = SnappyType::OTHER;
      return *this;
    }
    clearValue();
    copyFields(other);
    return *this;
  }

  inline ~ColumnValue() throw() {
    clearValue();
  }

  inline SnappyType::type getType() const throw () {
    return m_type;
  }

  inline void setType(const SnappyType::type type) throw () {
    m_type = type;
  }

  inline bool isSetBool() const throw () {
    return (m_type == SnappyType::BOOLEAN);
  }

  inline bool getBool() const throw () {
    return m_uval.bool_val;
  }

  inline void setBool(const bool val) {
    clearValue();
    m_uval.bool_val = val;
    m_type = SnappyType::BOOLEAN;
  }

  inline bool isSetByte() const throw () {
    return (m_type == SnappyType::TINYINT);
  }

  inline int8_t getByte() const throw () {
    return m_uval.byte_val;
  }

  inline void setByte(const int8_t val) {
    clearValue();
    m_uval.byte_val = val;
    m_type = SnappyType::TINYINT;
  }

  inline bool isSetI16() const throw () {
    return (m_type == SnappyType::SMALLINT);
  }

  inline int16_t getI16() const throw () {
    return m_uval.i16_val;
  }

  inline void setI16(const int16_t val) {
    clearValue();
    m_uval.i16_val = val;
    m_type = SnappyType::SMALLINT;
  }

  inline bool isSetI32() const throw () {
    return (m_type == SnappyType::INTEGER);
  }

  inline int32_t getI32() const throw () {
    return m_uval.i32_val;
  }

  inline void setI32(const int32_t val) {
    clearValue();
    m_uval.i32_val = val;
    m_type = SnappyType::INTEGER;
  }

  inline bool isSetI64() const throw () {
    return (m_type == SnappyType::BIGINT);
  }

  inline int64_t getI64() const throw () {
    return m_uval.i64_val;
  }

  inline void setI64(const int64_t val) {
    clearValue();
    m_uval.i64_val = val;
    m_type = SnappyType::BIGINT;
  }

  inline bool isSetFloat() const throw () {
    return (m_type == SnappyType::FLOAT);
  }

  inline float getFloat()  const throw (){
    return m_uval.float_val;
  }

  inline void setFloat(const float val) {
    clearValue();
    m_uval.float_val = val;
    m_type = SnappyType::FLOAT;
  }

  inline bool isSetDouble() const throw () {
    return (m_type == SnappyType::DOUBLE);
  }

  inline double getDouble() const throw () {
    return m_uval.double_val;
  }

  inline void setDouble(const double val) {
    clearValue();
    m_uval.double_val = val;
    m_type = SnappyType::DOUBLE;
  }

  inline bool isSetString() const throw () {
    return (m_type == SnappyType::VARCHAR);
  }

  inline std::string* getString() const throw () {
    return m_uval.string_binary_java_val;
  }

  inline void setString(const std::string& val) {
    if (m_type & (SnappyType::VARCHAR
        | SnappyType::BINARY
        | SnappyType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(val);
    } else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(val);
    }
    m_type = SnappyType::VARCHAR;
  }

  inline void setString(const char* val) {
    if (m_type & (SnappyType::VARCHAR
        | SnappyType::BINARY
        | SnappyType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(val);
    } else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(val);
    }
    m_type = SnappyType::VARCHAR;
  }

  // TODO: PERF: we could change thrift impl to carry through char* instead
  // of copying to std::string for cases where execute is going to be fired
  // immediately after setting the parameters. Same for setBinary.
  // Similarly when getting column values as result, we could send a char*
  // buffer to read the result into instead of creating a new std::string
  // (though it is dangerous and should avoid unless perf benefit is proven)
  inline void setString(const char* val, const int32_t len) {
    if (len >= 0) {
      if (m_type & (SnappyType::VARCHAR
          | SnappyType::BINARY
          | SnappyType::JAVA_OBJECT)) {
        m_uval.string_binary_java_val->assign(val, len);
      } else {
        clearValue();
        m_uval.string_binary_java_val = new std::string(val, len);
      }
      m_type = SnappyType::VARCHAR;
    } else {
      setString(val);
    }
  }

  inline bool isSetDecimal() const throw () {
    return (m_type == SnappyType::DECIMAL);
  }

  inline Decimal* getDecimal() const throw () {
    return m_uval.decimal_val;
  }

  inline void setDecimal(const Decimal& val) {
    if (isSetDecimal()) {
      m_uval.decimal_val->operator=(val);
    } else {
      clearValue();
      m_uval.decimal_val = new Decimal(val);
    }
    m_type = SnappyType::DECIMAL;
  }

  inline Decimal* initForDecimal() {
    if (isSetDecimal()) {
      return m_uval.decimal_val;
    } else {
      clearValue();
      m_uval.decimal_val = NULL;
      m_type = SnappyType::DECIMAL;
      return (m_uval.decimal_val = new Decimal());
    }
  }

  inline bool isSetDate() const throw () {
    return (m_type == SnappyType::DATE);
  }

  inline int64_t getDate() const throw () {
    return m_uval.date_time_epoch_val;
  }

  inline void setDate(const int64_t secsSinceEpoch) {
    clearValue();
    m_uval.date_time_epoch_val = secsSinceEpoch;
    m_type = SnappyType::DATE;
  }

  inline bool isSetTime() const throw () {
    return (m_type == SnappyType::TIME);
  }

  inline int64_t getTime() const throw () {
    return m_uval.date_time_epoch_val;
  }

  inline void setTime(const int64_t secsSinceEpoch) {
    clearValue();
    m_uval.date_time_epoch_val = secsSinceEpoch;
    m_type = SnappyType::TIME;
  }

  inline bool isSetTimestamp() const throw () {
    return (m_type == SnappyType::TIMESTAMP);
  }

  inline Timestamp getTimestamp() const throw () {
    return Timestamp(m_uval.timestamp_val.epochTime,
        m_uval.timestamp_val.nanos);
  }

  inline int64_t getTimestampEpoch() const throw () {
    return m_uval.timestamp_val.epochTime;
  }

  inline int32_t getTimestampNanos() const throw () {
    return m_uval.timestamp_val.nanos;
  }

  inline void setTimestamp(const Timestamp& val) {
    clearValue();
    m_uval.timestamp_val.epochTime = val.secsSinceEpoch;
    m_uval.timestamp_val.nanos = val.nanos;
    m_type = SnappyType::TIMESTAMP;
  }

  inline void setTimestamp(const int64_t epochTime,
      const int32_t nanos) {
    clearValue();
    m_uval.timestamp_val.epochTime = epochTime;
    m_uval.timestamp_val.nanos = nanos;
    m_type = SnappyType::TIMESTAMP;
  }

  inline bool isSetBinary() const throw () {
    return (m_type == SnappyType::BINARY);
  }

  inline std::string* getBinary() const throw () {
    return m_uval.string_binary_java_val;
  }

  inline void setBinary(const std::string& val) {
    if (m_type & (SnappyType::VARCHAR
        | SnappyType::BINARY
        | SnappyType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(val);
    } else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(val);
    }
    m_type = SnappyType::BINARY;
  }

  inline void setBinary(const char* val, const size_t len) {
    if (m_type & (SnappyType::VARCHAR
        | SnappyType::BINARY
        | SnappyType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(val, len);
    } else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(val, len);
    }
    m_type = SnappyType::BINARY;
  }

  inline bool isSetBlob() const throw () {
    return (m_type == SnappyType::BLOB);
  }

  inline BlobChunk* getBlob() const throw () {
    return m_uval.blob_val;
  }

  inline void setBlob(const BlobChunk& val) {
    if (isSetBlob()) {
      *m_uval.blob_val = val;
    } else {
      clearValue();
      m_uval.blob_val = new BlobChunk(val);
    }
    m_type = SnappyType::BLOB;
  }

  inline bool isSetClob() const throw () {
    return (m_type == SnappyType::CLOB);
  }

  inline ClobChunk* getClob() const throw () {
    return m_uval.clob_val;
  }

  inline void setClob(const ClobChunk& val) {
    if (isSetClob()) {
      *m_uval.clob_val = val;
    } else {
      clearValue();
      m_uval.clob_val = new ClobChunk(val);
    }
    m_type = SnappyType::CLOB;
  }

  inline bool isSetARRAY() const throw () {
    return (m_type == SnappyType::ARRAY);
  }

  inline std::vector<ColumnValue>* getARRAY() const throw () {
    return m_uval.array_val;
  }

  inline void setARRAY(const std::vector<ColumnValue>& val) {
    if (isSetARRAY()) {
      *m_uval.array_val = val;
    } else {
      clearValue();
      m_uval.array_val = new std::vector<ColumnValue>(val);
    }
    m_type = SnappyType::ARRAY;
  }

  inline bool isSetMAP() const throw () {
    return (m_type == SnappyType::MAP);
  }

  inline std::map<ColumnValue, ColumnValue>* getMAP() const throw () {
    return m_uval.map_val;
  }

  inline void setMAP(const std::map<ColumnValue, ColumnValue>& val) {
    if (isSetMAP()) {
      *m_uval.map_val = val;
    } else {
      clearValue();
      m_uval.map_val = new std::map<ColumnValue, ColumnValue>(val);
    }
    m_type = SnappyType::MAP;
  }

  inline bool isSetSTRUCT() const throw () {
    return (m_type == SnappyType::STRUCT);
  }

  inline std::vector<ColumnValue>* getSTRUCT() const throw () {
    return m_uval.struct_val;
  }

  inline void setSTRUCT(const std::vector<ColumnValue>& val) {
    if (isSetSTRUCT()) {
      *m_uval.struct_val = val;
    } else {
      clearValue();
      m_uval.struct_val = new std::vector<ColumnValue>(val);
    }
    m_type = SnappyType::STRUCT;
  }

  inline bool isNull() const throw () {
    return (m_type == SnappyType::NULLTYPE);
  }

  inline void setNull() {
    clearValue();
    m_uval.null_val = true;
    m_type = SnappyType::NULLTYPE;
  }

  inline bool isSetJSON() const throw () {
    return (m_type == SnappyType::JSON);
  }

  inline JSONObject* getJSON() const throw () {
    return m_uval.json_val;
  }

  inline void setJSON(const JSONObject& val) {
    if (isSetJSON()) {
      *m_uval.json_val = val;
    } else {
      clearValue();
      m_uval.json_val = new JSONObject(val);
    }
    m_type = SnappyType::JSON;
  }

  inline bool isSetJavaVal() const throw () {
    return (m_type == SnappyType::JAVA_OBJECT);
  }

  inline std::string* getJavaVal() const throw () {
    return m_uval.string_binary_java_val;
  }

  inline void setJavaVal(const std::string& val) {
    if (m_type & (SnappyType::VARCHAR
        | SnappyType::BINARY
        | SnappyType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(val);
    } else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(val);
    }
    m_type = SnappyType::JAVA_OBJECT;
  }

  inline void setString(std::string&& val) {
    if (m_type & (SnappyType::VARCHAR
        | SnappyType::BINARY
        | SnappyType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(std::move(val));
    } else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(std::move(val));
    }
    m_type = SnappyType::VARCHAR;
  }

  inline void setDecimal(Decimal&& val) {
    if (isSetDecimal()) {
      m_uval.decimal_val->operator=(std::move(val));
    } else {
      clearValue();
      m_uval.decimal_val = new Decimal(std::move(val));
    }
    m_type = SnappyType::DECIMAL;
  }

  inline void setBinary(std::string&& val) {
    if (m_type & (SnappyType::VARCHAR
        | SnappyType::BINARY
        | SnappyType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(std::move(val));
    } else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(std::move(val));
    }
    m_type = SnappyType::BINARY;
  }

  inline void setBlob(BlobChunk&& val) {
    if (isSetBlob()) {
      m_uval.blob_val->operator=(std::move(val));
    } else {
      clearValue();
      m_uval.blob_val = new BlobChunk(std::move(val));
    }
    m_type = SnappyType::BLOB;
  }

  inline void setClob(ClobChunk&& val) {
    if (isSetClob()) {
      m_uval.clob_val->operator=(std::move(val));
    } else {
      clearValue();
      m_uval.clob_val = new ClobChunk(std::move(val));
    }
    m_type = SnappyType::CLOB;
  }

  inline void setARRAY(std::vector<ColumnValue>&& val) {
    if (isSetARRAY()) {
      m_uval.array_val->operator=(std::move(val));
    } else {
      clearValue();
      m_uval.array_val = new std::vector<ColumnValue>(std::move(val));
    }
    m_type = SnappyType::ARRAY;
  }

  inline void setMAP(std::map<ColumnValue, ColumnValue>&& val) {
    if (isSetMAP()) {
      m_uval.map_val->operator=(std::move(val));
    } else {
      clearValue();
      m_uval.map_val = new std::map<ColumnValue, ColumnValue>(std::move(val));
    }
    m_type = SnappyType::MAP;
  }

  inline void setSTRUCT(std::vector<ColumnValue>&& val) {
    if (isSetSTRUCT()) {
      m_uval.struct_val->operator=(std::move(val));
    } else {
      clearValue();
      m_uval.struct_val = new std::vector<ColumnValue>(std::move(val));
    }
    m_type = SnappyType::STRUCT;
  }

  inline void setJSON(JSONObject&& val) {
    if (isSetJSON()) {
      m_uval.json_val->operator=(std::move(val));
    } else {
      clearValue();
      m_uval.json_val = new JSONObject(std::move(val));
    }
    m_type = SnappyType::JSON;
  }

  inline void setJavaVal(std::string&& val) {
    if (m_type & (SnappyType::VARCHAR
        | SnappyType::BINARY
        | SnappyType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(std::move(val));
    } else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(std::move(val));
    }
    m_type = SnappyType::JAVA_OBJECT;
  }

  bool operator == (const ColumnValue & rhs) const {
    const SnappyType::type type = m_type;
    if (type != rhs.m_type) return false;
    switch (type) {
      case SnappyType::VARCHAR:
      case SnappyType::CHAR:
      case SnappyType::LONGVARCHAR:
      case SnappyType::BINARY:
      case SnappyType::LONGVARBINARY:
      case SnappyType::JAVA_OBJECT:
        return *m_uval.string_binary_java_val
            == *rhs.m_uval.string_binary_java_val;
      case SnappyType::DECIMAL:
        return *m_uval.decimal_val == *rhs.m_uval.decimal_val;
      case SnappyType::BIGINT:
        return m_uval.i64_val == rhs.m_uval.i64_val;
      case SnappyType::BOOLEAN:
        return m_uval.bool_val == rhs.m_uval.bool_val;
      case SnappyType::DATE:
        return m_uval.date_time_epoch_val == rhs.m_uval.date_time_epoch_val;
      case SnappyType::DOUBLE:
        return m_uval.double_val == rhs.m_uval.double_val;
      case SnappyType::FLOAT:
        return m_uval.float_val == rhs.m_uval.float_val;
      case SnappyType::INTEGER:
        return m_uval.i32_val == rhs.m_uval.i32_val;
      case SnappyType::NULLTYPE:
        return true;
      case SnappyType::SMALLINT:
        return m_uval.i16_val == rhs.m_uval.i16_val;
      case SnappyType::TIME:
        return m_uval.date_time_epoch_val == rhs.m_uval.date_time_epoch_val;
      case SnappyType::TIMESTAMP:
        return m_uval.timestamp_val == rhs.m_uval.timestamp_val;
      case SnappyType::TINYINT:
        return m_uval.byte_val == rhs.m_uval.byte_val;
      case SnappyType::BLOB:
        return *m_uval.blob_val == *rhs.m_uval.blob_val;
      case SnappyType::CLOB:
        return *m_uval.clob_val == *rhs.m_uval.clob_val;
      case SnappyType::ARRAY:
        return *m_uval.array_val == *rhs.m_uval.array_val;
      case SnappyType::MAP:
        return *m_uval.map_val == *rhs.m_uval.map_val;
      case SnappyType::STRUCT:
        return *m_uval.struct_val == *rhs.m_uval.struct_val;
      case SnappyType::JSON:
        return *m_uval.json_val == *rhs.m_uval.json_val;
      default:
        return ::memcmp(&m_uval, &rhs.m_uval, sizeof(m_uval)) == 0;
    }
  }
  bool operator != (const ColumnValue &rhs) const {
    return *this != rhs;
  }

  bool operator < (const ColumnValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  void swap(ColumnValue& other);
  void printTo(std::ostream& out) const;
};

void swap(ColumnValue &a, ColumnValue &b);

inline std::ostream& operator<<(std::ostream& out, const ColumnValue& obj) {
  obj.printTo(out);
  return out;
}

}}} // namespace

#endif
