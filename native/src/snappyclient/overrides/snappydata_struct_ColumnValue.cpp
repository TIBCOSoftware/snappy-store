/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

/*
 * Changes for GemFireXD distributed data platform.
 *
 * Portions Copyright (c) 2010-2015 Pivotal Software, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License. You
 * may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License. See accompanying
 * LICENSE file.
 */
/*
 * Changes for SnappyData product.
 *
 * Portions Copyright (c) 2016 SnappyData, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License. You
 * may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License. See accompanying
 * LICENSE file.
 */

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "snappydata_struct_ColumnValue.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>
#include "Utils.h"

namespace io { namespace snappydata { namespace thrift {

void ColumnValue::copyFields(const ColumnValue& other) {
  m_uval = other.m_uval;
  switch (m_type) {
    case SnappyType::VARCHAR:
    case SnappyType::BINARY:
    case SnappyType::JAVA_OBJECT:
      m_uval.string_binary_java_val = new std::string(
          *other.m_uval.string_binary_java_val);
      break;
    case SnappyType::DECIMAL:
      m_uval.decimal_val = new Decimal(
          *other.m_uval.decimal_val);
      break;
    case SnappyType::BLOB:
      m_uval.blob_val = new BlobChunk(
          *other.m_uval.blob_val);
      break;
    case SnappyType::CLOB:
      m_uval.clob_val = new ClobChunk(
          *other.m_uval.clob_val);
      break;
    case SnappyType::ARRAY:
      m_uval.array_val = new std::vector<ColumnValue>(*other.m_uval.array_val);
      break;
    case SnappyType::MAP:
      m_uval.map_val = new std::map<ColumnValue, ColumnValue>(
          *other.m_uval.map_val);
      break;
    case SnappyType::STRUCT:
      m_uval.struct_val = new std::vector<ColumnValue>(*other.m_uval.struct_val);
      break;
    case SnappyType::JSON:
      m_uval.json_val = new JSONObject(
          *other.m_uval.json_val);
      break;
    default:
      break;
  }
}

void ColumnValue::clearValue() throw() {
  switch (m_type) {
    case SnappyType::OTHER:
      return;
    case SnappyType::VARCHAR:
    case SnappyType::BINARY:
    case SnappyType::JAVA_OBJECT:
      delete m_uval.string_binary_java_val;
      m_uval.string_binary_java_val = NULL;
      break;
    case SnappyType::DECIMAL:
      delete m_uval.decimal_val;
      m_uval.decimal_val = NULL;
      break;
    case SnappyType::BLOB:
      delete m_uval.blob_val;
      m_uval.blob_val = NULL;
      break;
    case SnappyType::CLOB:
      delete m_uval.clob_val;
      m_uval.clob_val = NULL;
      break;
    case SnappyType::ARRAY:
      delete m_uval.array_val;
      m_uval.array_val = NULL;
      break;
    case SnappyType::MAP:
      delete m_uval.map_val;
      m_uval.map_val = NULL;
      break;
    case SnappyType::STRUCT:
      delete m_uval.struct_val;
      m_uval.struct_val = NULL;
      break;
    case SnappyType::JSON:
      delete m_uval.json_val;
      m_uval.json_val = NULL;
      break;
    default:
      break;
  }
}

uint32_t ColumnValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  bool firstIter = true;
  while (true)
  {
    if (!firstIter) {
      clearValue();
    }
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(m_uval.bool_val);
          m_type = SnappyType::BOOLEAN;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(m_uval.byte_val);
          m_type = SnappyType::TINYINT;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(m_uval.i16_val);
          m_type = SnappyType::SMALLINT;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(m_uval.i32_val);
          m_type = SnappyType::INTEGER;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(m_uval.i64_val);
          m_type = SnappyType::BIGINT;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t i;
          xfer += iprot->readI32(i);
          m_uval.float_val = client::Utils::int32ToFloat(i);
          m_type = SnappyType::FLOAT;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(m_uval.double_val);
          m_type = SnappyType::DOUBLE;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          m_uval.string_binary_java_val = new std::string();
          m_type = SnappyType::VARCHAR;
          xfer += iprot->readString(*m_uval.string_binary_java_val);
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          m_uval.decimal_val = new Decimal();
          m_type = SnappyType::DECIMAL;
          xfer += m_uval.decimal_val->read(iprot);
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          DateTime d;
          xfer += d.read(iprot);
          m_uval.date_time_epoch_val = d.secsSinceEpoch;
          m_type = SnappyType::DATE;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          DateTime t;
          xfer += t.read(iprot);
          m_uval.date_time_epoch_val = t.secsSinceEpoch;
          m_type = SnappyType::TIME;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          Timestamp ts;
          xfer += ts.read(iprot);
          m_uval.timestamp_val.epochTime = ts.secsSinceEpoch;
          m_uval.timestamp_val.nanos = ts.nanos;
          m_type = SnappyType::TIMESTAMP;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          m_uval.string_binary_java_val = new std::string();
          m_type = SnappyType::BINARY;
          xfer += iprot->readBinary(*m_uval.string_binary_java_val);
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          m_uval.blob_val = new BlobChunk();
          m_type = SnappyType::BLOB;
          xfer += m_uval.blob_val->read(iprot);
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          m_uval.clob_val = new ClobChunk();
          m_type = SnappyType::CLOB;
          xfer += m_uval.clob_val->read(iprot);
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          uint32_t _size212;
          ::apache::thrift::protocol::TType _etype215;
          xfer += iprot->readListBegin(_etype215, _size212);
          m_uval.array_val = new std::vector<ColumnValue>(_size212);
          m_type = SnappyType::ARRAY;
          uint32_t _i216;
          for (_i216 = 0; _i216 < _size212; ++_i216) {
            xfer += m_uval.array_val->operator[](_i216).read(iprot);
          }
          xfer += iprot->readListEnd();
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          uint32_t _size217;
          ::apache::thrift::protocol::TType _ktype218;
          ::apache::thrift::protocol::TType _vtype219;
          xfer += iprot->readMapBegin(_ktype218, _vtype219, _size217);
          m_uval.map_val = new std::map<ColumnValue, ColumnValue>();
          m_type = SnappyType::MAP;
          uint32_t _i221;
          for (_i221 = 0; _i221 < _size217; ++_i221) {
            ColumnValue _key222;
            xfer += _key222.read(iprot);
            ColumnValue& _val223 = m_uval.map_val->operator[](_key222);
            xfer += _val223.read(iprot);
          }
          xfer += iprot->readMapEnd();
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          uint32_t _size224;
          ::apache::thrift::protocol::TType _etype227;
          xfer += iprot->readListBegin(_etype227, _size224);
          m_uval.struct_val = new std::vector<ColumnValue>(_size224);
          m_type = SnappyType::STRUCT;
          uint32_t _i228;
          for (_i228 = 0; _i228 < _size224; ++_i228) {
            xfer += m_uval.struct_val->operator[](_i228).read(iprot);
          }
          xfer += iprot->readListEnd();
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(*m_uval.null_val);
          m_type = SnappyType::NULLTYPE;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          m_uval.json_val = new JSONObject();
          m_type = SnappyType::JSON;
          xfer += m_uval.json_val->read(iprot);
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          m_uval.string_binary_java_val = new std::string();
          m_type = SnappyType::JAVA_OBJECT;
          xfer += iprot->readBinary(*m_uval.string_binary_java_val);
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
    firstIter = false;
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ColumnValue");

  switch (m_type) {
    case SnappyType::BOOLEAN:
      xfer += oprot->writeFieldBegin("bool_val",
          ::apache::thrift::protocol::T_BOOL, 1);
      xfer += oprot->writeBool(m_uval.bool_val);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::TINYINT:
      xfer += oprot->writeFieldBegin("byte_val",
          ::apache::thrift::protocol::T_BYTE, 2);
      xfer += oprot->writeByte(m_uval.byte_val);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::SMALLINT:
      xfer += oprot->writeFieldBegin("i16_val",
          ::apache::thrift::protocol::T_I16, 3);
      xfer += oprot->writeI16(m_uval.i16_val);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::INTEGER:
      xfer += oprot->writeFieldBegin("i32_val",
          ::apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32(m_uval.i32_val);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::BIGINT:
      xfer += oprot->writeFieldBegin("i64_val",
          ::apache::thrift::protocol::T_I64, 5);
      xfer += oprot->writeI64(m_uval.i64_val);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::FLOAT:
      xfer += oprot->writeFieldBegin("float_val",
          ::apache::thrift::protocol::T_I32, 6);
      xfer += oprot->writeI32(client::Utils::float2Int32(m_uval.float_val));
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::DOUBLE:
      xfer += oprot->writeFieldBegin("double_val",
          ::apache::thrift::protocol::T_DOUBLE, 7);
      xfer += oprot->writeDouble(m_uval.double_val);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::VARCHAR:
      xfer += oprot->writeFieldBegin("string_val",
          ::apache::thrift::protocol::T_STRING, 8);
      xfer += oprot->writeString(*m_uval.string_binary_java_val);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::DECIMAL:
      xfer += oprot->writeFieldBegin("decimal_val",
          ::apache::thrift::protocol::T_STRUCT, 9);
      xfer += m_uval.decimal_val->write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::DATE:
      xfer += oprot->writeFieldBegin("date_val",
          ::apache::thrift::protocol::T_STRUCT, 10);
      xfer += DateTime(m_uval.date_time_epoch_val).write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::TIME:
      xfer += oprot->writeFieldBegin("time_val",
          ::apache::thrift::protocol::T_STRUCT, 11);
      xfer += DateTime(m_uval.date_time_epoch_val).write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::TIMESTAMP:
      xfer += oprot->writeFieldBegin("timestamp_val",
          ::apache::thrift::protocol::T_STRUCT, 12);
      xfer += Timestamp(m_uval.timestamp_val.epochTime,
          m_uval.timestamp_val.nanos).write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::BINARY:
      xfer += oprot->writeFieldBegin("binary_val",
          ::apache::thrift::protocol::T_STRING, 13);
      xfer += oprot->writeBinary(*m_uval.string_binary_java_val);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::BLOB:
      xfer += oprot->writeFieldBegin("blob_val",
          ::apache::thrift::protocol::T_STRUCT, 14);
      xfer += m_uval.blob_val->write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::CLOB:
      xfer += oprot->writeFieldBegin("clob_val",
          ::apache::thrift::protocol::T_STRUCT, 15);
      xfer += m_uval.clob_val->write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::ARRAY:
      xfer += oprot->writeFieldBegin("array_val",
          ::apache::thrift::protocol::T_LIST, 16);
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
          static_cast<uint32_t>(m_uval.array_val->size()));
      std::vector<ColumnValue>::const_iterator _iter229;
      std::vector<ColumnValue>::const_iterator _iter229_end =
        m_uval.array_val->end();
      for (_iter229 = m_uval.array_val->begin();
          _iter229 != _iter229_end; ++_iter229) {
        xfer += (*_iter229).write(oprot);
      }
      xfer += oprot->writeListEnd();
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType:MAP:
      xfer += oprot->writeFieldBegin("map_val",
          ::apache::thrift::protocol::T_MAP, 17);
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT,
          ::apache::thrift::protocol::T_STRUCT,
          static_cast<uint32_t>(m_uval.map_val->size()));
      std::map<ColumnValue, ColumnValue>::const_iterator _iter230;
      std::map<ColumnValue, ColumnValue>::const_iterator _iter230_end =
        m_uval.map_val->end();
      for (_iter230 = m_uval.map_val->begin();
          _iter230 != _iter230_end; ++_iter230) {
        xfer += _iter230->first.write(oprot);
        xfer += _iter230->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::STRUCT:
      xfer += oprot->writeFieldBegin("struct_val",
          ::apache::thrift::protocol::T_LIST, 18);
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
          static_cast<uint32_t>(m_uval.struct_val->size()));
      std::vector<ColumnValue>::const_iterator _iter231;
      std::vector<ColumnValue>::const_iterator _iter231_end =
        m_uval.struct_val->end();
      for (_iter231 = m_uval.struct_val->begin();
          _iter231 != _iter231_end; ++_iter231) {
        xfer += (*_iter231).write(oprot);
      }
      xfer += oprot->writeListEnd();
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::NULLTYPE:
      xfer += oprot->writeFieldBegin("null_val",
          ::apache::thrift::protocol::T_BOOL, 16);
      xfer += oprot->writeBool(m_uval.null_val);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::JSON:
      xfer += oprot->writeFieldBegin("json_val",
          ::apache::thrift::protocol::T_STRUCT, 18);
      xfer += m_uval.json_val->write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    case SnappyType::JAVA_OBJECT:
      xfer += oprot->writeFieldBegin("java_val",
          ::apache::thrift::protocol::T_STRING, 19);
      xfer += oprot->writeBinary(*m_uval.string_binary_java_val);
      xfer += oprot->writeFieldEnd();
      break;
    default:
      break;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void ColumnValue::swap(ColumnValue& other) {
  using ::std::swap;
  swap(m_uval, other.m_uval);
  swap(m_type, other.m_type);
}

void swap(ColumnValue &a, ColumnValue &b) {
  a.swap(b);
}

void ColumnValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  switch (m_type) {
    case SnappyType::BOOLEAN:
      out << "bool_val=" << to_string(m_uval.bool_val);
      break;
    case SnappyType::TINYINT:
      out << "byte_val=" << to_string(m_uval.byte_val);
      break;
    case SnappyType::SMALLINT:
      out << "i16_val=" << to_string(m_uval.i16_val);
      break;
    case SnappyType::INTEGER:
      out << "i32_val=" << to_string(m_uval.i32_val);
      break;
    case SnappyType::BIGINT:
      out << "i64_val=" << to_string(m_uval.i64_val);
      break;
    case SnappyType::FLOAT:
      out << "float_val=" << to_string(m_uval.float_val);
      break;
    case SnappyType::DOUBLE:
      out << "double_val=" << to_string(m_uval.double_val);
      break;
    case SnappyType::VARCHAR:
      out << "string_val=" << to_string(*m_uval.string_val);
      break;
    case SnappyType::DECIMAL:
      out << "decimal_val=" << to_string(*m_uval.decimal_val);
      break;
    case SnappyType::DATE:
      out << "date_val=" << to_string(Date(m_uval.date_time_epoch_val));
      break;
    case SnappyType::TIME:
      out << "time_val=" << to_string(Date(m_uval.date_time_epoch_val));
      break;
    case SnappyType::TIMESTAMP:
      out << "timestamp_val=" << to_string(Timestamp(m_uval.timestamp_val));
      break;
    case SnappyType::BINARY:
      out << "binary_val=" << to_string(*m_uval.string_binary_java_val);
      break;
    case SnappyType::BLOB:
      out << "blob_val=" << to_string(*m_uval.blob_val);
      break;
    case SnappyType::CLOB:
      out << "clob_val=" << to_string(*m_uval.clob_val);
      break;
    case SnappyType::ARRAY:
      out << "array_val=(";
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
      std::vector<ColumnValue>::const_iterator _iter229;
      std::vector<ColumnValue>::const_iterator _iter229_end =
        m_uval.array_val->end();
      bool first_call = true;
      for (_iter229 = m_uval.array_val->begin();
          _iter229 != _iter229_end; ++_iter229) {
        if (first_call) {
          first_call = false;
        } else {
          out << ",";
        }
        out << to_string(*_iter229);
      }
      out << ")";
      break;
    case SnappyType:MAP:
      out << "map_val=(" << to_string(*m_uval.map_val) << ")";
      break;
    case SnappyType::STRUCT:
      out << "struct_val=(";
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT,
      std::vector<ColumnValue>::const_iterator _iter231;
      std::vector<ColumnValue>::const_iterator _iter231_end =
        m_uval.struct_val->end();
      bool first_call = true;
      for (_iter231 = m_uval.struct_val->begin();
          _iter231 != _iter231_end; ++_iter231) {
        if (first_call) {
          first_call = false;
        } else {
          out << ",";
        }
        out << to_string(*_iter231);
      }
      out << ")";
      break;
    case SnappyType::NULLTYPE:
      out << "null_val=" << to_string(m_uval.null_val);
      break;
    case SnappyType::JSON:
      out << "json_val=" << to_string(*m_uval.json_val);
      break;
    case SnappyType::JAVA_OBJECT:
      out << "java_val=" << to_string(*m_uval.string_binary_java_val);
      break;
    default:
      out << "<unknown>";
      break;
  }
}

}}}} // namespace
