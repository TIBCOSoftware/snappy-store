/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include "SnappyDataService.h"

namespace io { namespace snappydata { namespace thrift {


SnappyDataService_getPreferredServer_args::~SnappyDataService_getPreferredServer_args() throw() {
}


uint32_t SnappyDataService_getPreferredServer_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->serverTypes.clear();
            uint32_t _size386;
            ::apache::thrift::protocol::TType _etype389;
            xfer += iprot->readSetBegin(_etype389, _size386);
            uint32_t _i390;
            for (_i390 = 0; _i390 < _size386; ++_i390)
            {
              ServerType::type _elem391;
              int32_t ecast392;
              xfer += iprot->readI32(ecast392);
              _elem391 = (ServerType::type)ecast392;
              this->serverTypes.insert(_elem391);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.serverTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->serverGroups.clear();
            uint32_t _size393;
            ::apache::thrift::protocol::TType _etype396;
            xfer += iprot->readSetBegin(_etype396, _size393);
            uint32_t _i397;
            for (_i397 = 0; _i397 < _size393; ++_i397)
            {
              std::string _elem398;
              xfer += iprot->readString(_elem398);
              this->serverGroups.insert(_elem398);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.serverGroups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->failedServers.clear();
            uint32_t _size399;
            ::apache::thrift::protocol::TType _etype402;
            xfer += iprot->readSetBegin(_etype402, _size399);
            uint32_t _i403;
            for (_i403 = 0; _i403 < _size399; ++_i403)
            {
              HostAddress _elem404;
              xfer += _elem404.read(iprot);
              this->failedServers.insert(_elem404);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.failedServers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getPreferredServer_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getPreferredServer_args");

  xfer += oprot->writeFieldBegin("serverTypes", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->serverTypes.size()));
    std::set<ServerType::type> ::const_iterator _iter405;
    for (_iter405 = this->serverTypes.begin(); _iter405 != this->serverTypes.end(); ++_iter405)
    {
      xfer += oprot->writeI32((int32_t)(*_iter405));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverGroups", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->serverGroups.size()));
    std::set<std::string> ::const_iterator _iter406;
    for (_iter406 = this->serverGroups.begin(); _iter406 != this->serverGroups.end(); ++_iter406)
    {
      xfer += oprot->writeString((*_iter406));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failedServers", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->failedServers.size()));
    std::set<HostAddress> ::const_iterator _iter407;
    for (_iter407 = this->failedServers.begin(); _iter407 != this->failedServers.end(); ++_iter407)
    {
      xfer += (*_iter407).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getPreferredServer_pargs::~SnappyDataService_getPreferredServer_pargs() throw() {
}


uint32_t SnappyDataService_getPreferredServer_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getPreferredServer_pargs");

  xfer += oprot->writeFieldBegin("serverTypes", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->serverTypes)).size()));
    std::set<ServerType::type> ::const_iterator _iter408;
    for (_iter408 = (*(this->serverTypes)).begin(); _iter408 != (*(this->serverTypes)).end(); ++_iter408)
    {
      xfer += oprot->writeI32((int32_t)(*_iter408));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverGroups", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->serverGroups)).size()));
    std::set<std::string> ::const_iterator _iter409;
    for (_iter409 = (*(this->serverGroups)).begin(); _iter409 != (*(this->serverGroups)).end(); ++_iter409)
    {
      xfer += oprot->writeString((*_iter409));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failedServers", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->failedServers)).size()));
    std::set<HostAddress> ::const_iterator _iter410;
    for (_iter410 = (*(this->failedServers)).begin(); _iter410 != (*(this->failedServers)).end(); ++_iter410)
    {
      xfer += (*_iter410).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getPreferredServer_result::~SnappyDataService_getPreferredServer_result() throw() {
}


uint32_t SnappyDataService_getPreferredServer_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getPreferredServer_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getPreferredServer_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getPreferredServer_presult::~SnappyDataService_getPreferredServer_presult() throw() {
}


uint32_t SnappyDataService_getPreferredServer_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getAllServersWithPreferredServer_args::~SnappyDataService_getAllServersWithPreferredServer_args() throw() {
}


uint32_t SnappyDataService_getAllServersWithPreferredServer_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->serverTypes.clear();
            uint32_t _size411;
            ::apache::thrift::protocol::TType _etype414;
            xfer += iprot->readSetBegin(_etype414, _size411);
            uint32_t _i415;
            for (_i415 = 0; _i415 < _size411; ++_i415)
            {
              ServerType::type _elem416;
              int32_t ecast417;
              xfer += iprot->readI32(ecast417);
              _elem416 = (ServerType::type)ecast417;
              this->serverTypes.insert(_elem416);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.serverTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->serverGroups.clear();
            uint32_t _size418;
            ::apache::thrift::protocol::TType _etype421;
            xfer += iprot->readSetBegin(_etype421, _size418);
            uint32_t _i422;
            for (_i422 = 0; _i422 < _size418; ++_i422)
            {
              std::string _elem423;
              xfer += iprot->readString(_elem423);
              this->serverGroups.insert(_elem423);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.serverGroups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->failedServers.clear();
            uint32_t _size424;
            ::apache::thrift::protocol::TType _etype427;
            xfer += iprot->readSetBegin(_etype427, _size424);
            uint32_t _i428;
            for (_i428 = 0; _i428 < _size424; ++_i428)
            {
              HostAddress _elem429;
              xfer += _elem429.read(iprot);
              this->failedServers.insert(_elem429);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.failedServers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getAllServersWithPreferredServer_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getAllServersWithPreferredServer_args");

  xfer += oprot->writeFieldBegin("serverTypes", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->serverTypes.size()));
    std::set<ServerType::type> ::const_iterator _iter430;
    for (_iter430 = this->serverTypes.begin(); _iter430 != this->serverTypes.end(); ++_iter430)
    {
      xfer += oprot->writeI32((int32_t)(*_iter430));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverGroups", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->serverGroups.size()));
    std::set<std::string> ::const_iterator _iter431;
    for (_iter431 = this->serverGroups.begin(); _iter431 != this->serverGroups.end(); ++_iter431)
    {
      xfer += oprot->writeString((*_iter431));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failedServers", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->failedServers.size()));
    std::set<HostAddress> ::const_iterator _iter432;
    for (_iter432 = this->failedServers.begin(); _iter432 != this->failedServers.end(); ++_iter432)
    {
      xfer += (*_iter432).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getAllServersWithPreferredServer_pargs::~SnappyDataService_getAllServersWithPreferredServer_pargs() throw() {
}


uint32_t SnappyDataService_getAllServersWithPreferredServer_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getAllServersWithPreferredServer_pargs");

  xfer += oprot->writeFieldBegin("serverTypes", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->serverTypes)).size()));
    std::set<ServerType::type> ::const_iterator _iter433;
    for (_iter433 = (*(this->serverTypes)).begin(); _iter433 != (*(this->serverTypes)).end(); ++_iter433)
    {
      xfer += oprot->writeI32((int32_t)(*_iter433));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverGroups", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->serverGroups)).size()));
    std::set<std::string> ::const_iterator _iter434;
    for (_iter434 = (*(this->serverGroups)).begin(); _iter434 != (*(this->serverGroups)).end(); ++_iter434)
    {
      xfer += oprot->writeString((*_iter434));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("failedServers", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->failedServers)).size()));
    std::set<HostAddress> ::const_iterator _iter435;
    for (_iter435 = (*(this->failedServers)).begin(); _iter435 != (*(this->failedServers)).end(); ++_iter435)
    {
      xfer += (*_iter435).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getAllServersWithPreferredServer_result::~SnappyDataService_getAllServersWithPreferredServer_result() throw() {
}


uint32_t SnappyDataService_getAllServersWithPreferredServer_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size436;
            ::apache::thrift::protocol::TType _etype439;
            xfer += iprot->readListBegin(_etype439, _size436);
            this->success.resize(_size436);
            uint32_t _i440;
            for (_i440 = 0; _i440 < _size436; ++_i440)
            {
              xfer += this->success[_i440].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getAllServersWithPreferredServer_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getAllServersWithPreferredServer_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<HostAddress> ::const_iterator _iter441;
      for (_iter441 = this->success.begin(); _iter441 != this->success.end(); ++_iter441)
      {
        xfer += (*_iter441).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getAllServersWithPreferredServer_presult::~SnappyDataService_getAllServersWithPreferredServer_presult() throw() {
}


uint32_t SnappyDataService_getAllServersWithPreferredServer_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size442;
            ::apache::thrift::protocol::TType _etype445;
            xfer += iprot->readListBegin(_etype445, _size442);
            (*(this->success)).resize(_size442);
            uint32_t _i446;
            for (_i446 = 0; _i446 < _size442; ++_i446)
            {
              xfer += (*(this->success))[_i446].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_openConnection_args::~SnappyDataService_openConnection_args() throw() {
}


uint32_t SnappyDataService_openConnection_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->arguments.read(iprot);
          this->__isset.arguments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_openConnection_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_openConnection_args");

  xfer += oprot->writeFieldBegin("arguments", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->arguments.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_openConnection_pargs::~SnappyDataService_openConnection_pargs() throw() {
}


uint32_t SnappyDataService_openConnection_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_openConnection_pargs");

  xfer += oprot->writeFieldBegin("arguments", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->arguments)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_openConnection_result::~SnappyDataService_openConnection_result() throw() {
}


uint32_t SnappyDataService_openConnection_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_openConnection_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_openConnection_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_openConnection_presult::~SnappyDataService_openConnection_presult() throw() {
}


uint32_t SnappyDataService_openConnection_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_execute_args::~SnappyDataService_execute_args() throw() {
}


uint32_t SnappyDataService_execute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sql);
          this->__isset.sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->outputParams.clear();
            uint32_t _size447;
            ::apache::thrift::protocol::TType _ktype448;
            ::apache::thrift::protocol::TType _vtype449;
            xfer += iprot->readMapBegin(_ktype448, _vtype449, _size447);
            uint32_t _i451;
            for (_i451 = 0; _i451 < _size447; ++_i451)
            {
              int32_t _key452;
              xfer += iprot->readI32(_key452);
              OutputParameter& _val453 = this->outputParams[_key452];
              xfer += _val453.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.outputParams = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attrs.read(iprot);
          this->__isset.attrs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_execute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_execute_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sql);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outputParams.size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter454;
    for (_iter454 = this->outputParams.begin(); _iter454 != this->outputParams.end(); ++_iter454)
    {
      xfer += oprot->writeI32(_iter454->first);
      xfer += _iter454->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->attrs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_execute_pargs::~SnappyDataService_execute_pargs() throw() {
}


uint32_t SnappyDataService_execute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_execute_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->sql)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->outputParams)).size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter455;
    for (_iter455 = (*(this->outputParams)).begin(); _iter455 != (*(this->outputParams)).end(); ++_iter455)
    {
      xfer += oprot->writeI32(_iter455->first);
      xfer += _iter455->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->attrs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_execute_result::~SnappyDataService_execute_result() throw() {
}


uint32_t SnappyDataService_execute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_execute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_execute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_execute_presult::~SnappyDataService_execute_presult() throw() {
}


uint32_t SnappyDataService_execute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_executeUpdate_args::~SnappyDataService_executeUpdate_args() throw() {
}


uint32_t SnappyDataService_executeUpdate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sqls.clear();
            uint32_t _size456;
            ::apache::thrift::protocol::TType _etype459;
            xfer += iprot->readListBegin(_etype459, _size456);
            this->sqls.resize(_size456);
            uint32_t _i460;
            for (_i460 = 0; _i460 < _size456; ++_i460)
            {
              xfer += iprot->readString(this->sqls[_i460]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sqls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attrs.read(iprot);
          this->__isset.attrs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executeUpdate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executeUpdate_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sqls", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sqls.size()));
    std::vector<std::string> ::const_iterator _iter461;
    for (_iter461 = this->sqls.begin(); _iter461 != this->sqls.end(); ++_iter461)
    {
      xfer += oprot->writeString((*_iter461));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->attrs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeUpdate_pargs::~SnappyDataService_executeUpdate_pargs() throw() {
}


uint32_t SnappyDataService_executeUpdate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executeUpdate_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sqls", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*(this->sqls)).size()));
    std::vector<std::string> ::const_iterator _iter462;
    for (_iter462 = (*(this->sqls)).begin(); _iter462 != (*(this->sqls)).end(); ++_iter462)
    {
      xfer += oprot->writeString((*_iter462));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->attrs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeUpdate_result::~SnappyDataService_executeUpdate_result() throw() {
}


uint32_t SnappyDataService_executeUpdate_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executeUpdate_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_executeUpdate_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeUpdate_presult::~SnappyDataService_executeUpdate_presult() throw() {
}


uint32_t SnappyDataService_executeUpdate_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_executeQuery_args::~SnappyDataService_executeQuery_args() throw() {
}


uint32_t SnappyDataService_executeQuery_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sql);
          this->__isset.sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attrs.read(iprot);
          this->__isset.attrs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executeQuery_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executeQuery_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sql);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->attrs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeQuery_pargs::~SnappyDataService_executeQuery_pargs() throw() {
}


uint32_t SnappyDataService_executeQuery_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executeQuery_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->sql)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->attrs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeQuery_result::~SnappyDataService_executeQuery_result() throw() {
}


uint32_t SnappyDataService_executeQuery_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executeQuery_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_executeQuery_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeQuery_presult::~SnappyDataService_executeQuery_presult() throw() {
}


uint32_t SnappyDataService_executeQuery_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_prepareStatement_args::~SnappyDataService_prepareStatement_args() throw() {
}


uint32_t SnappyDataService_prepareStatement_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sql);
          this->__isset.sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->outputParams.clear();
            uint32_t _size463;
            ::apache::thrift::protocol::TType _ktype464;
            ::apache::thrift::protocol::TType _vtype465;
            xfer += iprot->readMapBegin(_ktype464, _vtype465, _size463);
            uint32_t _i467;
            for (_i467 = 0; _i467 < _size463; ++_i467)
            {
              int32_t _key468;
              xfer += iprot->readI32(_key468);
              OutputParameter& _val469 = this->outputParams[_key468];
              xfer += _val469.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.outputParams = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attrs.read(iprot);
          this->__isset.attrs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_prepareStatement_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_prepareStatement_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sql);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outputParams.size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter470;
    for (_iter470 = this->outputParams.begin(); _iter470 != this->outputParams.end(); ++_iter470)
    {
      xfer += oprot->writeI32(_iter470->first);
      xfer += _iter470->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->attrs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareStatement_pargs::~SnappyDataService_prepareStatement_pargs() throw() {
}


uint32_t SnappyDataService_prepareStatement_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_prepareStatement_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->sql)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->outputParams)).size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter471;
    for (_iter471 = (*(this->outputParams)).begin(); _iter471 != (*(this->outputParams)).end(); ++_iter471)
    {
      xfer += oprot->writeI32(_iter471->first);
      xfer += _iter471->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += (*(this->attrs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareStatement_result::~SnappyDataService_prepareStatement_result() throw() {
}


uint32_t SnappyDataService_prepareStatement_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_prepareStatement_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_prepareStatement_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareStatement_presult::~SnappyDataService_prepareStatement_presult() throw() {
}


uint32_t SnappyDataService_prepareStatement_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_executePrepared_args::~SnappyDataService_executePrepared_args() throw() {
}


uint32_t SnappyDataService_executePrepared_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stmtId);
          this->__isset.stmtId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->params.read(iprot);
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->outputParams.clear();
            uint32_t _size472;
            ::apache::thrift::protocol::TType _ktype473;
            ::apache::thrift::protocol::TType _vtype474;
            xfer += iprot->readMapBegin(_ktype473, _vtype474, _size472);
            uint32_t _i476;
            for (_i476 = 0; _i476 < _size472; ++_i476)
            {
              int32_t _key477;
              xfer += iprot->readI32(_key477);
              OutputParameter& _val478 = this->outputParams[_key477];
              xfer += _val478.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.outputParams = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePrepared_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePrepared_args");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->stmtId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outputParams.size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter479;
    for (_iter479 = this->outputParams.begin(); _iter479 != this->outputParams.end(); ++_iter479)
    {
      xfer += oprot->writeI32(_iter479->first);
      xfer += _iter479->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePrepared_pargs::~SnappyDataService_executePrepared_pargs() throw() {
}


uint32_t SnappyDataService_executePrepared_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePrepared_pargs");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->stmtId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->params)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->outputParams)).size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter480;
    for (_iter480 = (*(this->outputParams)).begin(); _iter480 != (*(this->outputParams)).end(); ++_iter480)
    {
      xfer += oprot->writeI32(_iter480->first);
      xfer += _iter480->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePrepared_result::~SnappyDataService_executePrepared_result() throw() {
}


uint32_t SnappyDataService_executePrepared_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePrepared_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_executePrepared_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePrepared_presult::~SnappyDataService_executePrepared_presult() throw() {
}


uint32_t SnappyDataService_executePrepared_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_executePreparedUpdate_args::~SnappyDataService_executePreparedUpdate_args() throw() {
}


uint32_t SnappyDataService_executePreparedUpdate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stmtId);
          this->__isset.stmtId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->params.read(iprot);
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePreparedUpdate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedUpdate_args");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->stmtId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedUpdate_pargs::~SnappyDataService_executePreparedUpdate_pargs() throw() {
}


uint32_t SnappyDataService_executePreparedUpdate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedUpdate_pargs");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->stmtId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->params)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedUpdate_result::~SnappyDataService_executePreparedUpdate_result() throw() {
}


uint32_t SnappyDataService_executePreparedUpdate_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePreparedUpdate_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedUpdate_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedUpdate_presult::~SnappyDataService_executePreparedUpdate_presult() throw() {
}


uint32_t SnappyDataService_executePreparedUpdate_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_executePreparedQuery_args::~SnappyDataService_executePreparedQuery_args() throw() {
}


uint32_t SnappyDataService_executePreparedQuery_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stmtId);
          this->__isset.stmtId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->params.read(iprot);
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePreparedQuery_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedQuery_args");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->stmtId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->params.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedQuery_pargs::~SnappyDataService_executePreparedQuery_pargs() throw() {
}


uint32_t SnappyDataService_executePreparedQuery_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedQuery_pargs");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->stmtId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->params)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedQuery_result::~SnappyDataService_executePreparedQuery_result() throw() {
}


uint32_t SnappyDataService_executePreparedQuery_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePreparedQuery_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedQuery_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedQuery_presult::~SnappyDataService_executePreparedQuery_presult() throw() {
}


uint32_t SnappyDataService_executePreparedQuery_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_executePreparedBatch_args::~SnappyDataService_executePreparedBatch_args() throw() {
}


uint32_t SnappyDataService_executePreparedBatch_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stmtId);
          this->__isset.stmtId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paramsBatch.clear();
            uint32_t _size481;
            ::apache::thrift::protocol::TType _etype484;
            xfer += iprot->readListBegin(_etype484, _size481);
            this->paramsBatch.resize(_size481);
            uint32_t _i485;
            for (_i485 = 0; _i485 < _size481; ++_i485)
            {
              xfer += this->paramsBatch[_i485].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.paramsBatch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePreparedBatch_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedBatch_args");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->stmtId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paramsBatch", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->paramsBatch.size()));
    std::vector<Row> ::const_iterator _iter486;
    for (_iter486 = this->paramsBatch.begin(); _iter486 != this->paramsBatch.end(); ++_iter486)
    {
      xfer += (*_iter486).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedBatch_pargs::~SnappyDataService_executePreparedBatch_pargs() throw() {
}


uint32_t SnappyDataService_executePreparedBatch_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedBatch_pargs");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->stmtId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paramsBatch", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->paramsBatch)).size()));
    std::vector<Row> ::const_iterator _iter487;
    for (_iter487 = (*(this->paramsBatch)).begin(); _iter487 != (*(this->paramsBatch)).end(); ++_iter487)
    {
      xfer += (*_iter487).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedBatch_result::~SnappyDataService_executePreparedBatch_result() throw() {
}


uint32_t SnappyDataService_executePreparedBatch_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executePreparedBatch_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_executePreparedBatch_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executePreparedBatch_presult::~SnappyDataService_executePreparedBatch_presult() throw() {
}


uint32_t SnappyDataService_executePreparedBatch_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_prepareAndExecute_args::~SnappyDataService_prepareAndExecute_args() throw() {
}


uint32_t SnappyDataService_prepareAndExecute_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sql);
          this->__isset.sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paramsBatch.clear();
            uint32_t _size488;
            ::apache::thrift::protocol::TType _etype491;
            xfer += iprot->readListBegin(_etype491, _size488);
            this->paramsBatch.resize(_size488);
            uint32_t _i492;
            for (_i492 = 0; _i492 < _size488; ++_i492)
            {
              xfer += this->paramsBatch[_i492].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.paramsBatch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->outputParams.clear();
            uint32_t _size493;
            ::apache::thrift::protocol::TType _ktype494;
            ::apache::thrift::protocol::TType _vtype495;
            xfer += iprot->readMapBegin(_ktype494, _vtype495, _size493);
            uint32_t _i497;
            for (_i497 = 0; _i497 < _size493; ++_i497)
            {
              int32_t _key498;
              xfer += iprot->readI32(_key498);
              OutputParameter& _val499 = this->outputParams[_key498];
              xfer += _val499.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.outputParams = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->attrs.read(iprot);
          this->__isset.attrs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_prepareAndExecute_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_prepareAndExecute_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sql);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paramsBatch", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->paramsBatch.size()));
    std::vector<Row> ::const_iterator _iter500;
    for (_iter500 = this->paramsBatch.begin(); _iter500 != this->paramsBatch.end(); ++_iter500)
    {
      xfer += (*_iter500).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outputParams.size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter501;
    for (_iter501 = this->outputParams.begin(); _iter501 != this->outputParams.end(); ++_iter501)
    {
      xfer += oprot->writeI32(_iter501->first);
      xfer += _iter501->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->attrs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareAndExecute_pargs::~SnappyDataService_prepareAndExecute_pargs() throw() {
}


uint32_t SnappyDataService_prepareAndExecute_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_prepareAndExecute_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->sql)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paramsBatch", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->paramsBatch)).size()));
    std::vector<Row> ::const_iterator _iter502;
    for (_iter502 = (*(this->paramsBatch)).begin(); _iter502 != (*(this->paramsBatch)).end(); ++_iter502)
    {
      xfer += (*_iter502).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outputParams", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->outputParams)).size()));
    std::map<int32_t, OutputParameter> ::const_iterator _iter503;
    for (_iter503 = (*(this->outputParams)).begin(); _iter503 != (*(this->outputParams)).end(); ++_iter503)
    {
      xfer += oprot->writeI32(_iter503->first);
      xfer += _iter503->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attrs", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += (*(this->attrs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareAndExecute_result::~SnappyDataService_prepareAndExecute_result() throw() {
}


uint32_t SnappyDataService_prepareAndExecute_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_prepareAndExecute_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_prepareAndExecute_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareAndExecute_presult::~SnappyDataService_prepareAndExecute_presult() throw() {
}


uint32_t SnappyDataService_prepareAndExecute_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_beginTransaction_args::~SnappyDataService_beginTransaction_args() throw() {
}


uint32_t SnappyDataService_beginTransaction_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->isolationLevel);
          this->__isset.isolationLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->flags.clear();
            uint32_t _size504;
            ::apache::thrift::protocol::TType _ktype505;
            ::apache::thrift::protocol::TType _vtype506;
            xfer += iprot->readMapBegin(_ktype505, _vtype506, _size504);
            uint32_t _i508;
            for (_i508 = 0; _i508 < _size504; ++_i508)
            {
              TransactionAttribute::type _key509;
              int32_t ecast511;
              xfer += iprot->readI32(ecast511);
              _key509 = (TransactionAttribute::type)ecast511;
              bool& _val510 = this->flags[_key509];
              xfer += iprot->readBool(_val510);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_beginTransaction_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_beginTransaction_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isolationLevel", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->isolationLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->flags.size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter512;
    for (_iter512 = this->flags.begin(); _iter512 != this->flags.end(); ++_iter512)
    {
      xfer += oprot->writeI32((int32_t)_iter512->first);
      xfer += oprot->writeBool(_iter512->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_beginTransaction_pargs::~SnappyDataService_beginTransaction_pargs() throw() {
}


uint32_t SnappyDataService_beginTransaction_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_beginTransaction_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isolationLevel", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->isolationLevel)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>((*(this->flags)).size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter513;
    for (_iter513 = (*(this->flags)).begin(); _iter513 != (*(this->flags)).end(); ++_iter513)
    {
      xfer += oprot->writeI32((int32_t)_iter513->first);
      xfer += oprot->writeBool(_iter513->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_beginTransaction_result::~SnappyDataService_beginTransaction_result() throw() {
}


uint32_t SnappyDataService_beginTransaction_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_beginTransaction_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_beginTransaction_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_beginTransaction_presult::~SnappyDataService_beginTransaction_presult() throw() {
}


uint32_t SnappyDataService_beginTransaction_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_setTransactionAttributes_args::~SnappyDataService_setTransactionAttributes_args() throw() {
}


uint32_t SnappyDataService_setTransactionAttributes_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->flags.clear();
            uint32_t _size514;
            ::apache::thrift::protocol::TType _ktype515;
            ::apache::thrift::protocol::TType _vtype516;
            xfer += iprot->readMapBegin(_ktype515, _vtype516, _size514);
            uint32_t _i518;
            for (_i518 = 0; _i518 < _size514; ++_i518)
            {
              TransactionAttribute::type _key519;
              int32_t ecast521;
              xfer += iprot->readI32(ecast521);
              _key519 = (TransactionAttribute::type)ecast521;
              bool& _val520 = this->flags[_key519];
              xfer += iprot->readBool(_val520);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_setTransactionAttributes_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_setTransactionAttributes_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->flags.size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter522;
    for (_iter522 = this->flags.begin(); _iter522 != this->flags.end(); ++_iter522)
    {
      xfer += oprot->writeI32((int32_t)_iter522->first);
      xfer += oprot->writeBool(_iter522->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_setTransactionAttributes_pargs::~SnappyDataService_setTransactionAttributes_pargs() throw() {
}


uint32_t SnappyDataService_setTransactionAttributes_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_setTransactionAttributes_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>((*(this->flags)).size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter523;
    for (_iter523 = (*(this->flags)).begin(); _iter523 != (*(this->flags)).end(); ++_iter523)
    {
      xfer += oprot->writeI32((int32_t)_iter523->first);
      xfer += oprot->writeBool(_iter523->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_setTransactionAttributes_result::~SnappyDataService_setTransactionAttributes_result() throw() {
}


uint32_t SnappyDataService_setTransactionAttributes_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_setTransactionAttributes_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_setTransactionAttributes_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_setTransactionAttributes_presult::~SnappyDataService_setTransactionAttributes_presult() throw() {
}


uint32_t SnappyDataService_setTransactionAttributes_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getTransactionAttributes_args::~SnappyDataService_getTransactionAttributes_args() throw() {
}


uint32_t SnappyDataService_getTransactionAttributes_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getTransactionAttributes_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getTransactionAttributes_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getTransactionAttributes_pargs::~SnappyDataService_getTransactionAttributes_pargs() throw() {
}


uint32_t SnappyDataService_getTransactionAttributes_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getTransactionAttributes_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getTransactionAttributes_result::~SnappyDataService_getTransactionAttributes_result() throw() {
}


uint32_t SnappyDataService_getTransactionAttributes_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size524;
            ::apache::thrift::protocol::TType _ktype525;
            ::apache::thrift::protocol::TType _vtype526;
            xfer += iprot->readMapBegin(_ktype525, _vtype526, _size524);
            uint32_t _i528;
            for (_i528 = 0; _i528 < _size524; ++_i528)
            {
              TransactionAttribute::type _key529;
              int32_t ecast531;
              xfer += iprot->readI32(ecast531);
              _key529 = (TransactionAttribute::type)ecast531;
              bool& _val530 = this->success[_key529];
              xfer += iprot->readBool(_val530);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getTransactionAttributes_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getTransactionAttributes_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->success.size()));
      std::map<TransactionAttribute::type, bool> ::const_iterator _iter532;
      for (_iter532 = this->success.begin(); _iter532 != this->success.end(); ++_iter532)
      {
        xfer += oprot->writeI32((int32_t)_iter532->first);
        xfer += oprot->writeBool(_iter532->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getTransactionAttributes_presult::~SnappyDataService_getTransactionAttributes_presult() throw() {
}


uint32_t SnappyDataService_getTransactionAttributes_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size533;
            ::apache::thrift::protocol::TType _ktype534;
            ::apache::thrift::protocol::TType _vtype535;
            xfer += iprot->readMapBegin(_ktype534, _vtype535, _size533);
            uint32_t _i537;
            for (_i537 = 0; _i537 < _size533; ++_i537)
            {
              TransactionAttribute::type _key538;
              int32_t ecast540;
              xfer += iprot->readI32(ecast540);
              _key538 = (TransactionAttribute::type)ecast540;
              bool& _val539 = (*(this->success))[_key538];
              xfer += iprot->readBool(_val539);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_commitTransaction_args::~SnappyDataService_commitTransaction_args() throw() {
}


uint32_t SnappyDataService_commitTransaction_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->startNewTransaction);
          this->__isset.startNewTransaction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->flags.clear();
            uint32_t _size541;
            ::apache::thrift::protocol::TType _ktype542;
            ::apache::thrift::protocol::TType _vtype543;
            xfer += iprot->readMapBegin(_ktype542, _vtype543, _size541);
            uint32_t _i545;
            for (_i545 = 0; _i545 < _size541; ++_i545)
            {
              TransactionAttribute::type _key546;
              int32_t ecast548;
              xfer += iprot->readI32(ecast548);
              _key546 = (TransactionAttribute::type)ecast548;
              bool& _val547 = this->flags[_key546];
              xfer += iprot->readBool(_val547);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_commitTransaction_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_commitTransaction_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startNewTransaction", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->startNewTransaction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->flags.size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter549;
    for (_iter549 = this->flags.begin(); _iter549 != this->flags.end(); ++_iter549)
    {
      xfer += oprot->writeI32((int32_t)_iter549->first);
      xfer += oprot->writeBool(_iter549->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_commitTransaction_pargs::~SnappyDataService_commitTransaction_pargs() throw() {
}


uint32_t SnappyDataService_commitTransaction_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_commitTransaction_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startNewTransaction", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->startNewTransaction)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>((*(this->flags)).size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter550;
    for (_iter550 = (*(this->flags)).begin(); _iter550 != (*(this->flags)).end(); ++_iter550)
    {
      xfer += oprot->writeI32((int32_t)_iter550->first);
      xfer += oprot->writeBool(_iter550->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_commitTransaction_result::~SnappyDataService_commitTransaction_result() throw() {
}


uint32_t SnappyDataService_commitTransaction_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_commitTransaction_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_commitTransaction_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_commitTransaction_presult::~SnappyDataService_commitTransaction_presult() throw() {
}


uint32_t SnappyDataService_commitTransaction_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_rollbackTransaction_args::~SnappyDataService_rollbackTransaction_args() throw() {
}


uint32_t SnappyDataService_rollbackTransaction_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->startNewTransaction);
          this->__isset.startNewTransaction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->flags.clear();
            uint32_t _size551;
            ::apache::thrift::protocol::TType _ktype552;
            ::apache::thrift::protocol::TType _vtype553;
            xfer += iprot->readMapBegin(_ktype552, _vtype553, _size551);
            uint32_t _i555;
            for (_i555 = 0; _i555 < _size551; ++_i555)
            {
              TransactionAttribute::type _key556;
              int32_t ecast558;
              xfer += iprot->readI32(ecast558);
              _key556 = (TransactionAttribute::type)ecast558;
              bool& _val557 = this->flags[_key556];
              xfer += iprot->readBool(_val557);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_rollbackTransaction_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_rollbackTransaction_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startNewTransaction", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->startNewTransaction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->flags.size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter559;
    for (_iter559 = this->flags.begin(); _iter559 != this->flags.end(); ++_iter559)
    {
      xfer += oprot->writeI32((int32_t)_iter559->first);
      xfer += oprot->writeBool(_iter559->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_rollbackTransaction_pargs::~SnappyDataService_rollbackTransaction_pargs() throw() {
}


uint32_t SnappyDataService_rollbackTransaction_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_rollbackTransaction_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startNewTransaction", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->startNewTransaction)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>((*(this->flags)).size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter560;
    for (_iter560 = (*(this->flags)).begin(); _iter560 != (*(this->flags)).end(); ++_iter560)
    {
      xfer += oprot->writeI32((int32_t)_iter560->first);
      xfer += oprot->writeBool(_iter560->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_rollbackTransaction_result::~SnappyDataService_rollbackTransaction_result() throw() {
}


uint32_t SnappyDataService_rollbackTransaction_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_rollbackTransaction_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_rollbackTransaction_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_rollbackTransaction_presult::~SnappyDataService_rollbackTransaction_presult() throw() {
}


uint32_t SnappyDataService_rollbackTransaction_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_prepareCommitTransaction_args::~SnappyDataService_prepareCommitTransaction_args() throw() {
}


uint32_t SnappyDataService_prepareCommitTransaction_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->flags.clear();
            uint32_t _size561;
            ::apache::thrift::protocol::TType _ktype562;
            ::apache::thrift::protocol::TType _vtype563;
            xfer += iprot->readMapBegin(_ktype562, _vtype563, _size561);
            uint32_t _i565;
            for (_i565 = 0; _i565 < _size561; ++_i565)
            {
              TransactionAttribute::type _key566;
              int32_t ecast568;
              xfer += iprot->readI32(ecast568);
              _key566 = (TransactionAttribute::type)ecast568;
              bool& _val567 = this->flags[_key566];
              xfer += iprot->readBool(_val567);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_prepareCommitTransaction_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_prepareCommitTransaction_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->flags.size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter569;
    for (_iter569 = this->flags.begin(); _iter569 != this->flags.end(); ++_iter569)
    {
      xfer += oprot->writeI32((int32_t)_iter569->first);
      xfer += oprot->writeBool(_iter569->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareCommitTransaction_pargs::~SnappyDataService_prepareCommitTransaction_pargs() throw() {
}


uint32_t SnappyDataService_prepareCommitTransaction_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_prepareCommitTransaction_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>((*(this->flags)).size()));
    std::map<TransactionAttribute::type, bool> ::const_iterator _iter570;
    for (_iter570 = (*(this->flags)).begin(); _iter570 != (*(this->flags)).end(); ++_iter570)
    {
      xfer += oprot->writeI32((int32_t)_iter570->first);
      xfer += oprot->writeBool(_iter570->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareCommitTransaction_result::~SnappyDataService_prepareCommitTransaction_result() throw() {
}


uint32_t SnappyDataService_prepareCommitTransaction_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_prepareCommitTransaction_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_prepareCommitTransaction_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_prepareCommitTransaction_presult::~SnappyDataService_prepareCommitTransaction_presult() throw() {
}


uint32_t SnappyDataService_prepareCommitTransaction_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getNextResultSet_args::~SnappyDataService_getNextResultSet_args() throw() {
}


uint32_t SnappyDataService_getNextResultSet_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cursorId);
          this->__isset.cursorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->otherResultSetBehaviour);
          this->__isset.otherResultSetBehaviour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getNextResultSet_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getNextResultSet_args");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->cursorId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("otherResultSetBehaviour", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->otherResultSetBehaviour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getNextResultSet_pargs::~SnappyDataService_getNextResultSet_pargs() throw() {
}


uint32_t SnappyDataService_getNextResultSet_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getNextResultSet_pargs");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->cursorId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("otherResultSetBehaviour", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte((*(this->otherResultSetBehaviour)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getNextResultSet_result::~SnappyDataService_getNextResultSet_result() throw() {
}


uint32_t SnappyDataService_getNextResultSet_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getNextResultSet_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getNextResultSet_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getNextResultSet_presult::~SnappyDataService_getNextResultSet_presult() throw() {
}


uint32_t SnappyDataService_getNextResultSet_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getBlobChunk_args::~SnappyDataService_getBlobChunk_args() throw() {
}


uint32_t SnappyDataService_getBlobChunk_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lobId);
          this->__isset.lobId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->freeLobAtEnd);
          this->__isset.freeLobAtEnd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getBlobChunk_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getBlobChunk_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lobId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->lobId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freeLobAtEnd", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->freeLobAtEnd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getBlobChunk_pargs::~SnappyDataService_getBlobChunk_pargs() throw() {
}


uint32_t SnappyDataService_getBlobChunk_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getBlobChunk_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lobId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->lobId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->size)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freeLobAtEnd", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->freeLobAtEnd)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getBlobChunk_result::~SnappyDataService_getBlobChunk_result() throw() {
}


uint32_t SnappyDataService_getBlobChunk_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getBlobChunk_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getBlobChunk_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getBlobChunk_presult::~SnappyDataService_getBlobChunk_presult() throw() {
}


uint32_t SnappyDataService_getBlobChunk_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getClobChunk_args::~SnappyDataService_getClobChunk_args() throw() {
}


uint32_t SnappyDataService_getClobChunk_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lobId);
          this->__isset.lobId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->freeLobAtEnd);
          this->__isset.freeLobAtEnd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getClobChunk_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getClobChunk_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lobId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->lobId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freeLobAtEnd", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->freeLobAtEnd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getClobChunk_pargs::~SnappyDataService_getClobChunk_pargs() throw() {
}


uint32_t SnappyDataService_getClobChunk_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getClobChunk_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lobId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->lobId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->size)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freeLobAtEnd", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool((*(this->freeLobAtEnd)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getClobChunk_result::~SnappyDataService_getClobChunk_result() throw() {
}


uint32_t SnappyDataService_getClobChunk_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getClobChunk_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getClobChunk_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getClobChunk_presult::~SnappyDataService_getClobChunk_presult() throw() {
}


uint32_t SnappyDataService_getClobChunk_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_sendBlobChunk_args::~SnappyDataService_sendBlobChunk_args() throw() {
}


uint32_t SnappyDataService_sendBlobChunk_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->chunk.read(iprot);
          this->__isset.chunk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_sendBlobChunk_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_sendBlobChunk_args");

  xfer += oprot->writeFieldBegin("chunk", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->chunk.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_sendBlobChunk_pargs::~SnappyDataService_sendBlobChunk_pargs() throw() {
}


uint32_t SnappyDataService_sendBlobChunk_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_sendBlobChunk_pargs");

  xfer += oprot->writeFieldBegin("chunk", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->chunk)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_sendBlobChunk_result::~SnappyDataService_sendBlobChunk_result() throw() {
}


uint32_t SnappyDataService_sendBlobChunk_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_sendBlobChunk_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_sendBlobChunk_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_sendBlobChunk_presult::~SnappyDataService_sendBlobChunk_presult() throw() {
}


uint32_t SnappyDataService_sendBlobChunk_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_sendClobChunk_args::~SnappyDataService_sendClobChunk_args() throw() {
}


uint32_t SnappyDataService_sendClobChunk_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->chunk.read(iprot);
          this->__isset.chunk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_sendClobChunk_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_sendClobChunk_args");

  xfer += oprot->writeFieldBegin("chunk", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->chunk.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_sendClobChunk_pargs::~SnappyDataService_sendClobChunk_pargs() throw() {
}


uint32_t SnappyDataService_sendClobChunk_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_sendClobChunk_pargs");

  xfer += oprot->writeFieldBegin("chunk", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->chunk)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_sendClobChunk_result::~SnappyDataService_sendClobChunk_result() throw() {
}


uint32_t SnappyDataService_sendClobChunk_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_sendClobChunk_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_sendClobChunk_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_sendClobChunk_presult::~SnappyDataService_sendClobChunk_presult() throw() {
}


uint32_t SnappyDataService_sendClobChunk_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_freeLob_args::~SnappyDataService_freeLob_args() throw() {
}


uint32_t SnappyDataService_freeLob_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lobId);
          this->__isset.lobId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_freeLob_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_freeLob_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lobId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->lobId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_freeLob_pargs::~SnappyDataService_freeLob_pargs() throw() {
}


uint32_t SnappyDataService_freeLob_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_freeLob_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lobId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->lobId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_freeLob_result::~SnappyDataService_freeLob_result() throw() {
}


uint32_t SnappyDataService_freeLob_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_freeLob_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_freeLob_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_freeLob_presult::~SnappyDataService_freeLob_presult() throw() {
}


uint32_t SnappyDataService_freeLob_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_scrollCursor_args::~SnappyDataService_scrollCursor_args() throw() {
}


uint32_t SnappyDataService_scrollCursor_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cursorId);
          this->__isset.cursorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->offsetIsAbsolute);
          this->__isset.offsetIsAbsolute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->fetchReverse);
          this->__isset.fetchReverse = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchSize);
          this->__isset.fetchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_scrollCursor_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_scrollCursor_args");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->cursorId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offsetIsAbsolute", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->offsetIsAbsolute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fetchReverse", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->fetchReverse);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->fetchSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_scrollCursor_pargs::~SnappyDataService_scrollCursor_pargs() throw() {
}


uint32_t SnappyDataService_scrollCursor_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_scrollCursor_pargs");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->cursorId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->offset)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offsetIsAbsolute", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->offsetIsAbsolute)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fetchReverse", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->fetchReverse)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((*(this->fetchSize)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_scrollCursor_result::~SnappyDataService_scrollCursor_result() throw() {
}


uint32_t SnappyDataService_scrollCursor_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_scrollCursor_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_scrollCursor_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_scrollCursor_presult::~SnappyDataService_scrollCursor_presult() throw() {
}


uint32_t SnappyDataService_scrollCursor_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_executeCursorUpdate_args::~SnappyDataService_executeCursorUpdate_args() throw() {
}


uint32_t SnappyDataService_executeCursorUpdate_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cursorId);
          this->__isset.cursorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->operations.clear();
            uint32_t _size571;
            ::apache::thrift::protocol::TType _etype574;
            xfer += iprot->readListBegin(_etype574, _size571);
            this->operations.resize(_size571);
            uint32_t _i575;
            for (_i575 = 0; _i575 < _size571; ++_i575)
            {
              int32_t ecast576;
              xfer += iprot->readI32(ecast576);
              this->operations[_i575] = (CursorUpdateOperation::type)ecast576;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.operations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->changedRows.clear();
            uint32_t _size577;
            ::apache::thrift::protocol::TType _etype580;
            xfer += iprot->readListBegin(_etype580, _size577);
            this->changedRows.resize(_size577);
            uint32_t _i581;
            for (_i581 = 0; _i581 < _size577; ++_i581)
            {
              xfer += this->changedRows[_i581].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.changedRows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->changedColumnsList.clear();
            uint32_t _size582;
            ::apache::thrift::protocol::TType _etype585;
            xfer += iprot->readListBegin(_etype585, _size582);
            this->changedColumnsList.resize(_size582);
            uint32_t _i586;
            for (_i586 = 0; _i586 < _size582; ++_i586)
            {
              {
                this->changedColumnsList[_i586].clear();
                uint32_t _size587;
                ::apache::thrift::protocol::TType _etype590;
                xfer += iprot->readListBegin(_etype590, _size587);
                this->changedColumnsList[_i586].resize(_size587);
                uint32_t _i591;
                for (_i591 = 0; _i591 < _size587; ++_i591)
                {
                  xfer += iprot->readI32(this->changedColumnsList[_i586][_i591]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.changedColumnsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->changedRowIndexes.clear();
            uint32_t _size592;
            ::apache::thrift::protocol::TType _etype595;
            xfer += iprot->readListBegin(_etype595, _size592);
            this->changedRowIndexes.resize(_size592);
            uint32_t _i596;
            for (_i596 = 0; _i596 < _size592; ++_i596)
            {
              xfer += iprot->readI32(this->changedRowIndexes[_i596]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.changedRowIndexes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executeCursorUpdate_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executeCursorUpdate_args");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->cursorId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operations", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->operations.size()));
    std::vector<CursorUpdateOperation::type> ::const_iterator _iter597;
    for (_iter597 = this->operations.begin(); _iter597 != this->operations.end(); ++_iter597)
    {
      xfer += oprot->writeI32((int32_t)(*_iter597));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changedRows", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->changedRows.size()));
    std::vector<Row> ::const_iterator _iter598;
    for (_iter598 = this->changedRows.begin(); _iter598 != this->changedRows.end(); ++_iter598)
    {
      xfer += (*_iter598).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changedColumnsList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->changedColumnsList.size()));
    std::vector<std::vector<int32_t> > ::const_iterator _iter599;
    for (_iter599 = this->changedColumnsList.begin(); _iter599 != this->changedColumnsList.end(); ++_iter599)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter599).size()));
        std::vector<int32_t> ::const_iterator _iter600;
        for (_iter600 = (*_iter599).begin(); _iter600 != (*_iter599).end(); ++_iter600)
        {
          xfer += oprot->writeI32((*_iter600));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changedRowIndexes", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->changedRowIndexes.size()));
    std::vector<int32_t> ::const_iterator _iter601;
    for (_iter601 = this->changedRowIndexes.begin(); _iter601 != this->changedRowIndexes.end(); ++_iter601)
    {
      xfer += oprot->writeI32((*_iter601));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeCursorUpdate_pargs::~SnappyDataService_executeCursorUpdate_pargs() throw() {
}


uint32_t SnappyDataService_executeCursorUpdate_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_executeCursorUpdate_pargs");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->cursorId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operations", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->operations)).size()));
    std::vector<CursorUpdateOperation::type> ::const_iterator _iter602;
    for (_iter602 = (*(this->operations)).begin(); _iter602 != (*(this->operations)).end(); ++_iter602)
    {
      xfer += oprot->writeI32((int32_t)(*_iter602));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changedRows", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->changedRows)).size()));
    std::vector<Row> ::const_iterator _iter603;
    for (_iter603 = (*(this->changedRows)).begin(); _iter603 != (*(this->changedRows)).end(); ++_iter603)
    {
      xfer += (*_iter603).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changedColumnsList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->changedColumnsList)).size()));
    std::vector<std::vector<int32_t> > ::const_iterator _iter604;
    for (_iter604 = (*(this->changedColumnsList)).begin(); _iter604 != (*(this->changedColumnsList)).end(); ++_iter604)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter604).size()));
        std::vector<int32_t> ::const_iterator _iter605;
        for (_iter605 = (*_iter604).begin(); _iter605 != (*_iter604).end(); ++_iter605)
        {
          xfer += oprot->writeI32((*_iter605));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("changedRowIndexes", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->changedRowIndexes)).size()));
    std::vector<int32_t> ::const_iterator _iter606;
    for (_iter606 = (*(this->changedRowIndexes)).begin(); _iter606 != (*(this->changedRowIndexes)).end(); ++_iter606)
    {
      xfer += oprot->writeI32((*_iter606));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeCursorUpdate_result::~SnappyDataService_executeCursorUpdate_result() throw() {
}


uint32_t SnappyDataService_executeCursorUpdate_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_executeCursorUpdate_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_executeCursorUpdate_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_executeCursorUpdate_presult::~SnappyDataService_executeCursorUpdate_presult() throw() {
}


uint32_t SnappyDataService_executeCursorUpdate_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getServiceMetaData_args::~SnappyDataService_getServiceMetaData_args() throw() {
}


uint32_t SnappyDataService_getServiceMetaData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getServiceMetaData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getServiceMetaData_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getServiceMetaData_pargs::~SnappyDataService_getServiceMetaData_pargs() throw() {
}


uint32_t SnappyDataService_getServiceMetaData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getServiceMetaData_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getServiceMetaData_result::~SnappyDataService_getServiceMetaData_result() throw() {
}


uint32_t SnappyDataService_getServiceMetaData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getServiceMetaData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getServiceMetaData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getServiceMetaData_presult::~SnappyDataService_getServiceMetaData_presult() throw() {
}


uint32_t SnappyDataService_getServiceMetaData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getSchemaMetaData_args::~SnappyDataService_getSchemaMetaData_args() throw() {
}


uint32_t SnappyDataService_getSchemaMetaData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast607;
          xfer += iprot->readI32(ecast607);
          this->schemaCall = (ServiceMetaDataCall::type)ecast607;
          this->__isset.schemaCall = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadataArgs.read(iprot);
          this->__isset.metadataArgs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getSchemaMetaData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getSchemaMetaData_args");

  xfer += oprot->writeFieldBegin("schemaCall", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->schemaCall);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->metadataArgs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getSchemaMetaData_pargs::~SnappyDataService_getSchemaMetaData_pargs() throw() {
}


uint32_t SnappyDataService_getSchemaMetaData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getSchemaMetaData_pargs");

  xfer += oprot->writeFieldBegin("schemaCall", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)(*(this->schemaCall)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->metadataArgs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getSchemaMetaData_result::~SnappyDataService_getSchemaMetaData_result() throw() {
}


uint32_t SnappyDataService_getSchemaMetaData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getSchemaMetaData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getSchemaMetaData_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getSchemaMetaData_presult::~SnappyDataService_getSchemaMetaData_presult() throw() {
}


uint32_t SnappyDataService_getSchemaMetaData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getIndexInfo_args::~SnappyDataService_getIndexInfo_args() throw() {
}


uint32_t SnappyDataService_getIndexInfo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadataArgs.read(iprot);
          this->__isset.metadataArgs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->unique);
          this->__isset.unique = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->approximate);
          this->__isset.approximate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getIndexInfo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getIndexInfo_args");

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->metadataArgs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unique", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->unique);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("approximate", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->approximate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getIndexInfo_pargs::~SnappyDataService_getIndexInfo_pargs() throw() {
}


uint32_t SnappyDataService_getIndexInfo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getIndexInfo_pargs");

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->metadataArgs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unique", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool((*(this->unique)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("approximate", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->approximate)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getIndexInfo_result::~SnappyDataService_getIndexInfo_result() throw() {
}


uint32_t SnappyDataService_getIndexInfo_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getIndexInfo_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getIndexInfo_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getIndexInfo_presult::~SnappyDataService_getIndexInfo_presult() throw() {
}


uint32_t SnappyDataService_getIndexInfo_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getUDTs_args::~SnappyDataService_getUDTs_args() throw() {
}


uint32_t SnappyDataService_getUDTs_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadataArgs.read(iprot);
          this->__isset.metadataArgs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->types.clear();
            uint32_t _size608;
            ::apache::thrift::protocol::TType _etype611;
            xfer += iprot->readListBegin(_etype611, _size608);
            this->types.resize(_size608);
            uint32_t _i612;
            for (_i612 = 0; _i612 < _size608; ++_i612)
            {
              int32_t ecast613;
              xfer += iprot->readI32(ecast613);
              this->types[_i612] = (SnappyType::type)ecast613;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getUDTs_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getUDTs_args");

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->metadataArgs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->types.size()));
    std::vector<SnappyType::type> ::const_iterator _iter614;
    for (_iter614 = this->types.begin(); _iter614 != this->types.end(); ++_iter614)
    {
      xfer += oprot->writeI32((int32_t)(*_iter614));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getUDTs_pargs::~SnappyDataService_getUDTs_pargs() throw() {
}


uint32_t SnappyDataService_getUDTs_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getUDTs_pargs");

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->metadataArgs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->types)).size()));
    std::vector<SnappyType::type> ::const_iterator _iter615;
    for (_iter615 = (*(this->types)).begin(); _iter615 != (*(this->types)).end(); ++_iter615)
    {
      xfer += oprot->writeI32((int32_t)(*_iter615));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getUDTs_result::~SnappyDataService_getUDTs_result() throw() {
}


uint32_t SnappyDataService_getUDTs_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getUDTs_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getUDTs_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getUDTs_presult::~SnappyDataService_getUDTs_presult() throw() {
}


uint32_t SnappyDataService_getUDTs_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_getBestRowIdentifier_args::~SnappyDataService_getBestRowIdentifier_args() throw() {
}


uint32_t SnappyDataService_getBestRowIdentifier_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadataArgs.read(iprot);
          this->__isset.metadataArgs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->scope);
          this->__isset.scope = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->nullable);
          this->__isset.nullable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getBestRowIdentifier_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getBestRowIdentifier_args");

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->metadataArgs.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scope", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->scope);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullable", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->nullable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getBestRowIdentifier_pargs::~SnappyDataService_getBestRowIdentifier_pargs() throw() {
}


uint32_t SnappyDataService_getBestRowIdentifier_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_getBestRowIdentifier_pargs");

  xfer += oprot->writeFieldBegin("metadataArgs", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->metadataArgs)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scope", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->scope)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullable", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->nullable)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getBestRowIdentifier_result::~SnappyDataService_getBestRowIdentifier_result() throw() {
}


uint32_t SnappyDataService_getBestRowIdentifier_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_getBestRowIdentifier_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_getBestRowIdentifier_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_getBestRowIdentifier_presult::~SnappyDataService_getBestRowIdentifier_presult() throw() {
}


uint32_t SnappyDataService_getBestRowIdentifier_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_fetchActiveConnections_args::~SnappyDataService_fetchActiveConnections_args() throw() {
}


uint32_t SnappyDataService_fetchActiveConnections_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_fetchActiveConnections_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_fetchActiveConnections_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_fetchActiveConnections_pargs::~SnappyDataService_fetchActiveConnections_pargs() throw() {
}


uint32_t SnappyDataService_fetchActiveConnections_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_fetchActiveConnections_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_fetchActiveConnections_result::~SnappyDataService_fetchActiveConnections_result() throw() {
}


uint32_t SnappyDataService_fetchActiveConnections_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size616;
            ::apache::thrift::protocol::TType _etype619;
            xfer += iprot->readListBegin(_etype619, _size616);
            this->success.resize(_size616);
            uint32_t _i620;
            for (_i620 = 0; _i620 < _size616; ++_i620)
            {
              xfer += this->success[_i620].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_fetchActiveConnections_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_fetchActiveConnections_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<ConnectionProperties> ::const_iterator _iter621;
      for (_iter621 = this->success.begin(); _iter621 != this->success.end(); ++_iter621)
      {
        xfer += (*_iter621).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_fetchActiveConnections_presult::~SnappyDataService_fetchActiveConnections_presult() throw() {
}


uint32_t SnappyDataService_fetchActiveConnections_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size622;
            ::apache::thrift::protocol::TType _etype625;
            xfer += iprot->readListBegin(_etype625, _size622);
            (*(this->success)).resize(_size622);
            uint32_t _i626;
            for (_i626 = 0; _i626 < _size622; ++_i626)
            {
              xfer += (*(this->success))[_i626].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_fetchActiveStatements_args::~SnappyDataService_fetchActiveStatements_args() throw() {
}


uint32_t SnappyDataService_fetchActiveStatements_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_fetchActiveStatements_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_fetchActiveStatements_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_fetchActiveStatements_pargs::~SnappyDataService_fetchActiveStatements_pargs() throw() {
}


uint32_t SnappyDataService_fetchActiveStatements_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_fetchActiveStatements_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_fetchActiveStatements_result::~SnappyDataService_fetchActiveStatements_result() throw() {
}


uint32_t SnappyDataService_fetchActiveStatements_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->success.clear();
            uint32_t _size627;
            ::apache::thrift::protocol::TType _ktype628;
            ::apache::thrift::protocol::TType _vtype629;
            xfer += iprot->readMapBegin(_ktype628, _vtype629, _size627);
            uint32_t _i631;
            for (_i631 = 0; _i631 < _size627; ++_i631)
            {
              int32_t _key632;
              xfer += iprot->readI32(_key632);
              std::string& _val633 = this->success[_key632];
              xfer += iprot->readString(_val633);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_fetchActiveStatements_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_fetchActiveStatements_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_MAP, 0);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::map<int32_t, std::string> ::const_iterator _iter634;
      for (_iter634 = this->success.begin(); _iter634 != this->success.end(); ++_iter634)
      {
        xfer += oprot->writeI32(_iter634->first);
        xfer += oprot->writeString(_iter634->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  } else if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_fetchActiveStatements_presult::~SnappyDataService_fetchActiveStatements_presult() throw() {
}


uint32_t SnappyDataService_fetchActiveStatements_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            (*(this->success)).clear();
            uint32_t _size635;
            ::apache::thrift::protocol::TType _ktype636;
            ::apache::thrift::protocol::TType _vtype637;
            xfer += iprot->readMapBegin(_ktype636, _vtype637, _size635);
            uint32_t _i639;
            for (_i639 = 0; _i639 < _size635; ++_i639)
            {
              int32_t _key640;
              xfer += iprot->readI32(_key640);
              std::string& _val641 = (*(this->success))[_key640];
              xfer += iprot->readString(_val641);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_cancelStatement_args::~SnappyDataService_cancelStatement_args() throw() {
}


uint32_t SnappyDataService_cancelStatement_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stmtId);
          this->__isset.stmtId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_cancelStatement_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_cancelStatement_args");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->stmtId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_cancelStatement_pargs::~SnappyDataService_cancelStatement_pargs() throw() {
}


uint32_t SnappyDataService_cancelStatement_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_cancelStatement_pargs");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->stmtId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_cancelStatement_result::~SnappyDataService_cancelStatement_result() throw() {
}


uint32_t SnappyDataService_cancelStatement_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_cancelStatement_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_cancelStatement_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_cancelStatement_presult::~SnappyDataService_cancelStatement_presult() throw() {
}


uint32_t SnappyDataService_cancelStatement_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_closeResultSet_args::~SnappyDataService_closeResultSet_args() throw() {
}


uint32_t SnappyDataService_closeResultSet_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cursorId);
          this->__isset.cursorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_closeResultSet_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_closeResultSet_args");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->cursorId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_closeResultSet_pargs::~SnappyDataService_closeResultSet_pargs() throw() {
}


uint32_t SnappyDataService_closeResultSet_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_closeResultSet_pargs");

  xfer += oprot->writeFieldBegin("cursorId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->cursorId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_closeResultSet_result::~SnappyDataService_closeResultSet_result() throw() {
}


uint32_t SnappyDataService_closeResultSet_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_closeResultSet_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_closeResultSet_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_closeResultSet_presult::~SnappyDataService_closeResultSet_presult() throw() {
}


uint32_t SnappyDataService_closeResultSet_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_closeStatement_args::~SnappyDataService_closeStatement_args() throw() {
}


uint32_t SnappyDataService_closeStatement_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stmtId);
          this->__isset.stmtId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_closeStatement_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_closeStatement_args");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->stmtId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_closeStatement_pargs::~SnappyDataService_closeStatement_pargs() throw() {
}


uint32_t SnappyDataService_closeStatement_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_closeStatement_pargs");

  xfer += oprot->writeFieldBegin("stmtId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->stmtId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_closeStatement_result::~SnappyDataService_closeStatement_result() throw() {
}


uint32_t SnappyDataService_closeStatement_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_closeStatement_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("SnappyDataService_closeStatement_result");

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->error.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_closeStatement_presult::~SnappyDataService_closeStatement_presult() throw() {
}


uint32_t SnappyDataService_closeStatement_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->error.read(iprot);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


SnappyDataService_closeConnection_args::~SnappyDataService_closeConnection_args() throw() {
}


uint32_t SnappyDataService_closeConnection_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_closeConnection_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_closeConnection_args");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->token);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_closeConnection_pargs::~SnappyDataService_closeConnection_pargs() throw() {
}


uint32_t SnappyDataService_closeConnection_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_closeConnection_pargs");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->connId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->token)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_bulkClose_args::~SnappyDataService_bulkClose_args() throw() {
}


uint32_t SnappyDataService_bulkClose_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->entities.clear();
            uint32_t _size642;
            ::apache::thrift::protocol::TType _etype645;
            xfer += iprot->readListBegin(_etype645, _size642);
            this->entities.resize(_size642);
            uint32_t _i646;
            for (_i646 = 0; _i646 < _size642; ++_i646)
            {
              xfer += this->entities[_i646].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.entities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnappyDataService_bulkClose_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_bulkClose_args");

  xfer += oprot->writeFieldBegin("entities", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->entities.size()));
    std::vector<EntityId> ::const_iterator _iter647;
    for (_iter647 = this->entities.begin(); _iter647 != this->entities.end(); ++_iter647)
    {
      xfer += (*_iter647).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


SnappyDataService_bulkClose_pargs::~SnappyDataService_bulkClose_pargs() throw() {
}


uint32_t SnappyDataService_bulkClose_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SnappyDataService_bulkClose_pargs");

  xfer += oprot->writeFieldBegin("entities", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->entities)).size()));
    std::vector<EntityId> ::const_iterator _iter648;
    for (_iter648 = (*(this->entities)).begin(); _iter648 != (*(this->entities)).end(); ++_iter648)
    {
      xfer += (*_iter648).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void SnappyDataServiceClient::getPreferredServer(HostAddress& _return, const std::set<ServerType::type> & serverTypes, const std::set<std::string> & serverGroups, const std::set<HostAddress> & failedServers)
{
  send_getPreferredServer(serverTypes, serverGroups, failedServers);
  recv_getPreferredServer(_return);
}

void SnappyDataServiceClient::send_getPreferredServer(const std::set<ServerType::type> & serverTypes, const std::set<std::string> & serverGroups, const std::set<HostAddress> & failedServers)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getPreferredServer", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getPreferredServer_pargs args;
  args.serverTypes = &serverTypes;
  args.serverGroups = &serverGroups;
  args.failedServers = &failedServers;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getPreferredServer(HostAddress& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getPreferredServer") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getPreferredServer_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getPreferredServer failed: unknown result");
}

void SnappyDataServiceClient::getAllServersWithPreferredServer(std::vector<HostAddress> & _return, const std::set<ServerType::type> & serverTypes, const std::set<std::string> & serverGroups, const std::set<HostAddress> & failedServers)
{
  send_getAllServersWithPreferredServer(serverTypes, serverGroups, failedServers);
  recv_getAllServersWithPreferredServer(_return);
}

void SnappyDataServiceClient::send_getAllServersWithPreferredServer(const std::set<ServerType::type> & serverTypes, const std::set<std::string> & serverGroups, const std::set<HostAddress> & failedServers)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getAllServersWithPreferredServer", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getAllServersWithPreferredServer_pargs args;
  args.serverTypes = &serverTypes;
  args.serverGroups = &serverGroups;
  args.failedServers = &failedServers;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getAllServersWithPreferredServer(std::vector<HostAddress> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getAllServersWithPreferredServer") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getAllServersWithPreferredServer_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getAllServersWithPreferredServer failed: unknown result");
}

void SnappyDataServiceClient::openConnection(ConnectionProperties& _return, const OpenConnectionArgs& arguments)
{
  send_openConnection(arguments);
  recv_openConnection(_return);
}

void SnappyDataServiceClient::send_openConnection(const OpenConnectionArgs& arguments)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("openConnection", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_openConnection_pargs args;
  args.arguments = &arguments;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_openConnection(ConnectionProperties& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("openConnection") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_openConnection_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "openConnection failed: unknown result");
}

void SnappyDataServiceClient::execute(StatementResult& _return, const int32_t connId, const std::string& sql, const std::map<int32_t, OutputParameter> & outputParams, const StatementAttrs& attrs, const std::string& token)
{
  send_execute(connId, sql, outputParams, attrs, token);
  recv_execute(_return);
}

void SnappyDataServiceClient::send_execute(const int32_t connId, const std::string& sql, const std::map<int32_t, OutputParameter> & outputParams, const StatementAttrs& attrs, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("execute", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_execute_pargs args;
  args.connId = &connId;
  args.sql = &sql;
  args.outputParams = &outputParams;
  args.attrs = &attrs;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_execute(StatementResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("execute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_execute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "execute failed: unknown result");
}

void SnappyDataServiceClient::executeUpdate(UpdateResult& _return, const int32_t connId, const std::vector<std::string> & sqls, const StatementAttrs& attrs, const std::string& token)
{
  send_executeUpdate(connId, sqls, attrs, token);
  recv_executeUpdate(_return);
}

void SnappyDataServiceClient::send_executeUpdate(const int32_t connId, const std::vector<std::string> & sqls, const StatementAttrs& attrs, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("executeUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_executeUpdate_pargs args;
  args.connId = &connId;
  args.sqls = &sqls;
  args.attrs = &attrs;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_executeUpdate(UpdateResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("executeUpdate") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_executeUpdate_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "executeUpdate failed: unknown result");
}

void SnappyDataServiceClient::executeQuery(RowSet& _return, const int32_t connId, const std::string& sql, const StatementAttrs& attrs, const std::string& token)
{
  send_executeQuery(connId, sql, attrs, token);
  recv_executeQuery(_return);
}

void SnappyDataServiceClient::send_executeQuery(const int32_t connId, const std::string& sql, const StatementAttrs& attrs, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("executeQuery", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_executeQuery_pargs args;
  args.connId = &connId;
  args.sql = &sql;
  args.attrs = &attrs;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_executeQuery(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("executeQuery") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_executeQuery_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "executeQuery failed: unknown result");
}

void SnappyDataServiceClient::prepareStatement(PrepareResult& _return, const int32_t connId, const std::string& sql, const std::map<int32_t, OutputParameter> & outputParams, const StatementAttrs& attrs, const std::string& token)
{
  send_prepareStatement(connId, sql, outputParams, attrs, token);
  recv_prepareStatement(_return);
}

void SnappyDataServiceClient::send_prepareStatement(const int32_t connId, const std::string& sql, const std::map<int32_t, OutputParameter> & outputParams, const StatementAttrs& attrs, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("prepareStatement", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_prepareStatement_pargs args;
  args.connId = &connId;
  args.sql = &sql;
  args.outputParams = &outputParams;
  args.attrs = &attrs;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_prepareStatement(PrepareResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("prepareStatement") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_prepareStatement_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "prepareStatement failed: unknown result");
}

void SnappyDataServiceClient::executePrepared(StatementResult& _return, const int32_t stmtId, const Row& params, const std::map<int32_t, OutputParameter> & outputParams, const std::string& token)
{
  send_executePrepared(stmtId, params, outputParams, token);
  recv_executePrepared(_return);
}

void SnappyDataServiceClient::send_executePrepared(const int32_t stmtId, const Row& params, const std::map<int32_t, OutputParameter> & outputParams, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("executePrepared", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_executePrepared_pargs args;
  args.stmtId = &stmtId;
  args.params = &params;
  args.outputParams = &outputParams;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_executePrepared(StatementResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("executePrepared") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_executePrepared_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "executePrepared failed: unknown result");
}

void SnappyDataServiceClient::executePreparedUpdate(UpdateResult& _return, const int32_t stmtId, const Row& params, const std::string& token)
{
  send_executePreparedUpdate(stmtId, params, token);
  recv_executePreparedUpdate(_return);
}

void SnappyDataServiceClient::send_executePreparedUpdate(const int32_t stmtId, const Row& params, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("executePreparedUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_executePreparedUpdate_pargs args;
  args.stmtId = &stmtId;
  args.params = &params;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_executePreparedUpdate(UpdateResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("executePreparedUpdate") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_executePreparedUpdate_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "executePreparedUpdate failed: unknown result");
}

void SnappyDataServiceClient::executePreparedQuery(RowSet& _return, const int32_t stmtId, const Row& params, const std::string& token)
{
  send_executePreparedQuery(stmtId, params, token);
  recv_executePreparedQuery(_return);
}

void SnappyDataServiceClient::send_executePreparedQuery(const int32_t stmtId, const Row& params, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("executePreparedQuery", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_executePreparedQuery_pargs args;
  args.stmtId = &stmtId;
  args.params = &params;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_executePreparedQuery(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("executePreparedQuery") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_executePreparedQuery_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "executePreparedQuery failed: unknown result");
}

void SnappyDataServiceClient::executePreparedBatch(UpdateResult& _return, const int32_t stmtId, const std::vector<Row> & paramsBatch, const std::string& token)
{
  send_executePreparedBatch(stmtId, paramsBatch, token);
  recv_executePreparedBatch(_return);
}

void SnappyDataServiceClient::send_executePreparedBatch(const int32_t stmtId, const std::vector<Row> & paramsBatch, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("executePreparedBatch", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_executePreparedBatch_pargs args;
  args.stmtId = &stmtId;
  args.paramsBatch = &paramsBatch;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_executePreparedBatch(UpdateResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("executePreparedBatch") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_executePreparedBatch_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "executePreparedBatch failed: unknown result");
}

void SnappyDataServiceClient::prepareAndExecute(StatementResult& _return, const int32_t connId, const std::string& sql, const std::vector<Row> & paramsBatch, const std::map<int32_t, OutputParameter> & outputParams, const StatementAttrs& attrs, const std::string& token)
{
  send_prepareAndExecute(connId, sql, paramsBatch, outputParams, attrs, token);
  recv_prepareAndExecute(_return);
}

void SnappyDataServiceClient::send_prepareAndExecute(const int32_t connId, const std::string& sql, const std::vector<Row> & paramsBatch, const std::map<int32_t, OutputParameter> & outputParams, const StatementAttrs& attrs, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("prepareAndExecute", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_prepareAndExecute_pargs args;
  args.connId = &connId;
  args.sql = &sql;
  args.paramsBatch = &paramsBatch;
  args.outputParams = &outputParams;
  args.attrs = &attrs;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_prepareAndExecute(StatementResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("prepareAndExecute") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_prepareAndExecute_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "prepareAndExecute failed: unknown result");
}

void SnappyDataServiceClient::beginTransaction(const int32_t connId, const int8_t isolationLevel, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  send_beginTransaction(connId, isolationLevel, flags, token);
  recv_beginTransaction();
}

void SnappyDataServiceClient::send_beginTransaction(const int32_t connId, const int8_t isolationLevel, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("beginTransaction", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_beginTransaction_pargs args;
  args.connId = &connId;
  args.isolationLevel = &isolationLevel;
  args.flags = &flags;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_beginTransaction()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("beginTransaction") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_beginTransaction_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::setTransactionAttributes(const int32_t connId, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  send_setTransactionAttributes(connId, flags, token);
  recv_setTransactionAttributes();
}

void SnappyDataServiceClient::send_setTransactionAttributes(const int32_t connId, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("setTransactionAttributes", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_setTransactionAttributes_pargs args;
  args.connId = &connId;
  args.flags = &flags;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_setTransactionAttributes()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("setTransactionAttributes") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_setTransactionAttributes_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::getTransactionAttributes(std::map<TransactionAttribute::type, bool> & _return, const int32_t connId, const std::string& token)
{
  send_getTransactionAttributes(connId, token);
  recv_getTransactionAttributes(_return);
}

void SnappyDataServiceClient::send_getTransactionAttributes(const int32_t connId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getTransactionAttributes", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getTransactionAttributes_pargs args;
  args.connId = &connId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getTransactionAttributes(std::map<TransactionAttribute::type, bool> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getTransactionAttributes") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getTransactionAttributes_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getTransactionAttributes failed: unknown result");
}

void SnappyDataServiceClient::commitTransaction(const int32_t connId, const bool startNewTransaction, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  send_commitTransaction(connId, startNewTransaction, flags, token);
  recv_commitTransaction();
}

void SnappyDataServiceClient::send_commitTransaction(const int32_t connId, const bool startNewTransaction, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("commitTransaction", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_commitTransaction_pargs args;
  args.connId = &connId;
  args.startNewTransaction = &startNewTransaction;
  args.flags = &flags;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_commitTransaction()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("commitTransaction") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_commitTransaction_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::rollbackTransaction(const int32_t connId, const bool startNewTransaction, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  send_rollbackTransaction(connId, startNewTransaction, flags, token);
  recv_rollbackTransaction();
}

void SnappyDataServiceClient::send_rollbackTransaction(const int32_t connId, const bool startNewTransaction, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("rollbackTransaction", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_rollbackTransaction_pargs args;
  args.connId = &connId;
  args.startNewTransaction = &startNewTransaction;
  args.flags = &flags;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_rollbackTransaction()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("rollbackTransaction") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_rollbackTransaction_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

bool SnappyDataServiceClient::prepareCommitTransaction(const int32_t connId, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  send_prepareCommitTransaction(connId, flags, token);
  return recv_prepareCommitTransaction();
}

void SnappyDataServiceClient::send_prepareCommitTransaction(const int32_t connId, const std::map<TransactionAttribute::type, bool> & flags, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("prepareCommitTransaction", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_prepareCommitTransaction_pargs args;
  args.connId = &connId;
  args.flags = &flags;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool SnappyDataServiceClient::recv_prepareCommitTransaction()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("prepareCommitTransaction") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  SnappyDataService_prepareCommitTransaction_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "prepareCommitTransaction failed: unknown result");
}

void SnappyDataServiceClient::getNextResultSet(RowSet& _return, const int32_t cursorId, const int8_t otherResultSetBehaviour, const std::string& token)
{
  send_getNextResultSet(cursorId, otherResultSetBehaviour, token);
  recv_getNextResultSet(_return);
}

void SnappyDataServiceClient::send_getNextResultSet(const int32_t cursorId, const int8_t otherResultSetBehaviour, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getNextResultSet", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getNextResultSet_pargs args;
  args.cursorId = &cursorId;
  args.otherResultSetBehaviour = &otherResultSetBehaviour;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getNextResultSet(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getNextResultSet") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getNextResultSet_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getNextResultSet failed: unknown result");
}

void SnappyDataServiceClient::getBlobChunk(BlobChunk& _return, const int32_t connId, const int32_t lobId, const int64_t offset, const int32_t size, const bool freeLobAtEnd, const std::string& token)
{
  send_getBlobChunk(connId, lobId, offset, size, freeLobAtEnd, token);
  recv_getBlobChunk(_return);
}

void SnappyDataServiceClient::send_getBlobChunk(const int32_t connId, const int32_t lobId, const int64_t offset, const int32_t size, const bool freeLobAtEnd, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getBlobChunk", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getBlobChunk_pargs args;
  args.connId = &connId;
  args.lobId = &lobId;
  args.offset = &offset;
  args.size = &size;
  args.freeLobAtEnd = &freeLobAtEnd;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getBlobChunk(BlobChunk& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getBlobChunk") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getBlobChunk_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getBlobChunk failed: unknown result");
}

void SnappyDataServiceClient::getClobChunk(ClobChunk& _return, const int32_t connId, const int32_t lobId, const int64_t offset, const int32_t size, const bool freeLobAtEnd, const std::string& token)
{
  send_getClobChunk(connId, lobId, offset, size, freeLobAtEnd, token);
  recv_getClobChunk(_return);
}

void SnappyDataServiceClient::send_getClobChunk(const int32_t connId, const int32_t lobId, const int64_t offset, const int32_t size, const bool freeLobAtEnd, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getClobChunk", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getClobChunk_pargs args;
  args.connId = &connId;
  args.lobId = &lobId;
  args.offset = &offset;
  args.size = &size;
  args.freeLobAtEnd = &freeLobAtEnd;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getClobChunk(ClobChunk& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getClobChunk") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getClobChunk_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getClobChunk failed: unknown result");
}

int32_t SnappyDataServiceClient::sendBlobChunk(const BlobChunk& chunk, const int32_t connId, const std::string& token)
{
  send_sendBlobChunk(chunk, connId, token);
  return recv_sendBlobChunk();
}

void SnappyDataServiceClient::send_sendBlobChunk(const BlobChunk& chunk, const int32_t connId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sendBlobChunk", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_sendBlobChunk_pargs args;
  args.chunk = &chunk;
  args.connId = &connId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t SnappyDataServiceClient::recv_sendBlobChunk()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sendBlobChunk") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  SnappyDataService_sendBlobChunk_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sendBlobChunk failed: unknown result");
}

int32_t SnappyDataServiceClient::sendClobChunk(const ClobChunk& chunk, const int32_t connId, const std::string& token)
{
  send_sendClobChunk(chunk, connId, token);
  return recv_sendClobChunk();
}

void SnappyDataServiceClient::send_sendClobChunk(const ClobChunk& chunk, const int32_t connId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("sendClobChunk", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_sendClobChunk_pargs args;
  args.chunk = &chunk;
  args.connId = &connId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t SnappyDataServiceClient::recv_sendClobChunk()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("sendClobChunk") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  SnappyDataService_sendClobChunk_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "sendClobChunk failed: unknown result");
}

void SnappyDataServiceClient::freeLob(const int32_t connId, const int32_t lobId, const std::string& token)
{
  send_freeLob(connId, lobId, token);
  recv_freeLob();
}

void SnappyDataServiceClient::send_freeLob(const int32_t connId, const int32_t lobId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("freeLob", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_freeLob_pargs args;
  args.connId = &connId;
  args.lobId = &lobId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_freeLob()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("freeLob") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_freeLob_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::scrollCursor(RowSet& _return, const int32_t cursorId, const int32_t offset, const bool offsetIsAbsolute, const bool fetchReverse, const int32_t fetchSize, const std::string& token)
{
  send_scrollCursor(cursorId, offset, offsetIsAbsolute, fetchReverse, fetchSize, token);
  recv_scrollCursor(_return);
}

void SnappyDataServiceClient::send_scrollCursor(const int32_t cursorId, const int32_t offset, const bool offsetIsAbsolute, const bool fetchReverse, const int32_t fetchSize, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("scrollCursor", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_scrollCursor_pargs args;
  args.cursorId = &cursorId;
  args.offset = &offset;
  args.offsetIsAbsolute = &offsetIsAbsolute;
  args.fetchReverse = &fetchReverse;
  args.fetchSize = &fetchSize;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_scrollCursor(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("scrollCursor") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_scrollCursor_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "scrollCursor failed: unknown result");
}

void SnappyDataServiceClient::executeCursorUpdate(const int32_t cursorId, const std::vector<CursorUpdateOperation::type> & operations, const std::vector<Row> & changedRows, const std::vector<std::vector<int32_t> > & changedColumnsList, const std::vector<int32_t> & changedRowIndexes, const std::string& token)
{
  send_executeCursorUpdate(cursorId, operations, changedRows, changedColumnsList, changedRowIndexes, token);
  recv_executeCursorUpdate();
}

void SnappyDataServiceClient::send_executeCursorUpdate(const int32_t cursorId, const std::vector<CursorUpdateOperation::type> & operations, const std::vector<Row> & changedRows, const std::vector<std::vector<int32_t> > & changedColumnsList, const std::vector<int32_t> & changedRowIndexes, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("executeCursorUpdate", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_executeCursorUpdate_pargs args;
  args.cursorId = &cursorId;
  args.operations = &operations;
  args.changedRows = &changedRows;
  args.changedColumnsList = &changedColumnsList;
  args.changedRowIndexes = &changedRowIndexes;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_executeCursorUpdate()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("executeCursorUpdate") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_executeCursorUpdate_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::getServiceMetaData(ServiceMetaData& _return, const int32_t connId, const std::string& token)
{
  send_getServiceMetaData(connId, token);
  recv_getServiceMetaData(_return);
}

void SnappyDataServiceClient::send_getServiceMetaData(const int32_t connId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getServiceMetaData", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getServiceMetaData_pargs args;
  args.connId = &connId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getServiceMetaData(ServiceMetaData& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getServiceMetaData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getServiceMetaData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getServiceMetaData failed: unknown result");
}

void SnappyDataServiceClient::getSchemaMetaData(RowSet& _return, const ServiceMetaDataCall::type schemaCall, const ServiceMetaDataArgs& metadataArgs)
{
  send_getSchemaMetaData(schemaCall, metadataArgs);
  recv_getSchemaMetaData(_return);
}

void SnappyDataServiceClient::send_getSchemaMetaData(const ServiceMetaDataCall::type schemaCall, const ServiceMetaDataArgs& metadataArgs)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getSchemaMetaData", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getSchemaMetaData_pargs args;
  args.schemaCall = &schemaCall;
  args.metadataArgs = &metadataArgs;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getSchemaMetaData(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getSchemaMetaData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getSchemaMetaData_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getSchemaMetaData failed: unknown result");
}

void SnappyDataServiceClient::getIndexInfo(RowSet& _return, const ServiceMetaDataArgs& metadataArgs, const bool unique, const bool approximate)
{
  send_getIndexInfo(metadataArgs, unique, approximate);
  recv_getIndexInfo(_return);
}

void SnappyDataServiceClient::send_getIndexInfo(const ServiceMetaDataArgs& metadataArgs, const bool unique, const bool approximate)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getIndexInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getIndexInfo_pargs args;
  args.metadataArgs = &metadataArgs;
  args.unique = &unique;
  args.approximate = &approximate;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getIndexInfo(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getIndexInfo") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getIndexInfo_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getIndexInfo failed: unknown result");
}

void SnappyDataServiceClient::getUDTs(RowSet& _return, const ServiceMetaDataArgs& metadataArgs, const std::vector<SnappyType::type> & types)
{
  send_getUDTs(metadataArgs, types);
  recv_getUDTs(_return);
}

void SnappyDataServiceClient::send_getUDTs(const ServiceMetaDataArgs& metadataArgs, const std::vector<SnappyType::type> & types)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getUDTs", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getUDTs_pargs args;
  args.metadataArgs = &metadataArgs;
  args.types = &types;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getUDTs(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getUDTs") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getUDTs_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getUDTs failed: unknown result");
}

void SnappyDataServiceClient::getBestRowIdentifier(RowSet& _return, const ServiceMetaDataArgs& metadataArgs, const int32_t scope, const bool nullable)
{
  send_getBestRowIdentifier(metadataArgs, scope, nullable);
  recv_getBestRowIdentifier(_return);
}

void SnappyDataServiceClient::send_getBestRowIdentifier(const ServiceMetaDataArgs& metadataArgs, const int32_t scope, const bool nullable)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getBestRowIdentifier", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_getBestRowIdentifier_pargs args;
  args.metadataArgs = &metadataArgs;
  args.scope = &scope;
  args.nullable = &nullable;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_getBestRowIdentifier(RowSet& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getBestRowIdentifier") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_getBestRowIdentifier_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getBestRowIdentifier failed: unknown result");
}

void SnappyDataServiceClient::fetchActiveConnections(std::vector<ConnectionProperties> & _return, const int32_t connId, const std::string& token)
{
  send_fetchActiveConnections(connId, token);
  recv_fetchActiveConnections(_return);
}

void SnappyDataServiceClient::send_fetchActiveConnections(const int32_t connId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("fetchActiveConnections", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_fetchActiveConnections_pargs args;
  args.connId = &connId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_fetchActiveConnections(std::vector<ConnectionProperties> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("fetchActiveConnections") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_fetchActiveConnections_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "fetchActiveConnections failed: unknown result");
}

void SnappyDataServiceClient::fetchActiveStatements(std::map<int32_t, std::string> & _return, const int32_t connId, const std::string& token)
{
  send_fetchActiveStatements(connId, token);
  recv_fetchActiveStatements(_return);
}

void SnappyDataServiceClient::send_fetchActiveStatements(const int32_t connId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("fetchActiveStatements", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_fetchActiveStatements_pargs args;
  args.connId = &connId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_fetchActiveStatements(std::map<int32_t, std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("fetchActiveStatements") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_fetchActiveStatements_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  if (result.__isset.error) {
    throw result.error;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "fetchActiveStatements failed: unknown result");
}

void SnappyDataServiceClient::cancelStatement(const int32_t stmtId, const std::string& token)
{
  send_cancelStatement(stmtId, token);
  recv_cancelStatement();
}

void SnappyDataServiceClient::send_cancelStatement(const int32_t stmtId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("cancelStatement", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_cancelStatement_pargs args;
  args.stmtId = &stmtId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_cancelStatement()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("cancelStatement") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_cancelStatement_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::closeResultSet(const int32_t cursorId, const std::string& token)
{
  send_closeResultSet(cursorId, token);
  recv_closeResultSet();
}

void SnappyDataServiceClient::send_closeResultSet(const int32_t cursorId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("closeResultSet", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_closeResultSet_pargs args;
  args.cursorId = &cursorId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_closeResultSet()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("closeResultSet") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_closeResultSet_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::closeStatement(const int32_t stmtId, const std::string& token)
{
  send_closeStatement(stmtId, token);
  recv_closeStatement();
}

void SnappyDataServiceClient::send_closeStatement(const int32_t stmtId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("closeStatement", ::apache::thrift::protocol::T_CALL, cseqid);

  SnappyDataService_closeStatement_pargs args;
  args.stmtId = &stmtId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::recv_closeStatement()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("closeStatement") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  SnappyDataService_closeStatement_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.error) {
    throw result.error;
  }
  return;
}

void SnappyDataServiceClient::closeConnection(const int32_t connId, const std::string& token)
{
  send_closeConnection(connId, token);
}

void SnappyDataServiceClient::send_closeConnection(const int32_t connId, const std::string& token)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("closeConnection", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  SnappyDataService_closeConnection_pargs args;
  args.connId = &connId;
  args.token = &token;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void SnappyDataServiceClient::bulkClose(const std::vector<EntityId> & entities)
{
  send_bulkClose(entities);
}

void SnappyDataServiceClient::send_bulkClose(const std::vector<EntityId> & entities)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("bulkClose", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  SnappyDataService_bulkClose_pargs args;
  args.entities = &entities;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool SnappyDataServiceProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void SnappyDataServiceProcessor::process_getPreferredServer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getPreferredServer", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getPreferredServer");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getPreferredServer");
  }

  SnappyDataService_getPreferredServer_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getPreferredServer", bytes);
  }

  SnappyDataService_getPreferredServer_result result;
  try {
    iface_->getPreferredServer(result.success, args.serverTypes, args.serverGroups, args.failedServers);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getPreferredServer");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getPreferredServer", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getPreferredServer");
  }

  oprot->writeMessageBegin("getPreferredServer", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getPreferredServer", bytes);
  }
}

void SnappyDataServiceProcessor::process_getAllServersWithPreferredServer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getAllServersWithPreferredServer", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getAllServersWithPreferredServer");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getAllServersWithPreferredServer");
  }

  SnappyDataService_getAllServersWithPreferredServer_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getAllServersWithPreferredServer", bytes);
  }

  SnappyDataService_getAllServersWithPreferredServer_result result;
  try {
    iface_->getAllServersWithPreferredServer(result.success, args.serverTypes, args.serverGroups, args.failedServers);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getAllServersWithPreferredServer");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getAllServersWithPreferredServer", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getAllServersWithPreferredServer");
  }

  oprot->writeMessageBegin("getAllServersWithPreferredServer", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getAllServersWithPreferredServer", bytes);
  }
}

void SnappyDataServiceProcessor::process_openConnection(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.openConnection", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.openConnection");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.openConnection");
  }

  SnappyDataService_openConnection_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.openConnection", bytes);
  }

  SnappyDataService_openConnection_result result;
  try {
    iface_->openConnection(result.success, args.arguments);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.openConnection");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("openConnection", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.openConnection");
  }

  oprot->writeMessageBegin("openConnection", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.openConnection", bytes);
  }
}

void SnappyDataServiceProcessor::process_execute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.execute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.execute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.execute");
  }

  SnappyDataService_execute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.execute", bytes);
  }

  SnappyDataService_execute_result result;
  try {
    iface_->execute(result.success, args.connId, args.sql, args.outputParams, args.attrs, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.execute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("execute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.execute");
  }

  oprot->writeMessageBegin("execute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.execute", bytes);
  }
}

void SnappyDataServiceProcessor::process_executeUpdate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.executeUpdate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.executeUpdate");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.executeUpdate");
  }

  SnappyDataService_executeUpdate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.executeUpdate", bytes);
  }

  SnappyDataService_executeUpdate_result result;
  try {
    iface_->executeUpdate(result.success, args.connId, args.sqls, args.attrs, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.executeUpdate");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("executeUpdate", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.executeUpdate");
  }

  oprot->writeMessageBegin("executeUpdate", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.executeUpdate", bytes);
  }
}

void SnappyDataServiceProcessor::process_executeQuery(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.executeQuery", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.executeQuery");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.executeQuery");
  }

  SnappyDataService_executeQuery_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.executeQuery", bytes);
  }

  SnappyDataService_executeQuery_result result;
  try {
    iface_->executeQuery(result.success, args.connId, args.sql, args.attrs, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.executeQuery");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("executeQuery", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.executeQuery");
  }

  oprot->writeMessageBegin("executeQuery", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.executeQuery", bytes);
  }
}

void SnappyDataServiceProcessor::process_prepareStatement(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.prepareStatement", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.prepareStatement");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.prepareStatement");
  }

  SnappyDataService_prepareStatement_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.prepareStatement", bytes);
  }

  SnappyDataService_prepareStatement_result result;
  try {
    iface_->prepareStatement(result.success, args.connId, args.sql, args.outputParams, args.attrs, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.prepareStatement");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("prepareStatement", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.prepareStatement");
  }

  oprot->writeMessageBegin("prepareStatement", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.prepareStatement", bytes);
  }
}

void SnappyDataServiceProcessor::process_executePrepared(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.executePrepared", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.executePrepared");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.executePrepared");
  }

  SnappyDataService_executePrepared_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.executePrepared", bytes);
  }

  SnappyDataService_executePrepared_result result;
  try {
    iface_->executePrepared(result.success, args.stmtId, args.params, args.outputParams, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.executePrepared");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("executePrepared", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.executePrepared");
  }

  oprot->writeMessageBegin("executePrepared", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.executePrepared", bytes);
  }
}

void SnappyDataServiceProcessor::process_executePreparedUpdate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.executePreparedUpdate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.executePreparedUpdate");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.executePreparedUpdate");
  }

  SnappyDataService_executePreparedUpdate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.executePreparedUpdate", bytes);
  }

  SnappyDataService_executePreparedUpdate_result result;
  try {
    iface_->executePreparedUpdate(result.success, args.stmtId, args.params, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.executePreparedUpdate");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("executePreparedUpdate", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.executePreparedUpdate");
  }

  oprot->writeMessageBegin("executePreparedUpdate", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.executePreparedUpdate", bytes);
  }
}

void SnappyDataServiceProcessor::process_executePreparedQuery(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.executePreparedQuery", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.executePreparedQuery");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.executePreparedQuery");
  }

  SnappyDataService_executePreparedQuery_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.executePreparedQuery", bytes);
  }

  SnappyDataService_executePreparedQuery_result result;
  try {
    iface_->executePreparedQuery(result.success, args.stmtId, args.params, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.executePreparedQuery");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("executePreparedQuery", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.executePreparedQuery");
  }

  oprot->writeMessageBegin("executePreparedQuery", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.executePreparedQuery", bytes);
  }
}

void SnappyDataServiceProcessor::process_executePreparedBatch(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.executePreparedBatch", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.executePreparedBatch");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.executePreparedBatch");
  }

  SnappyDataService_executePreparedBatch_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.executePreparedBatch", bytes);
  }

  SnappyDataService_executePreparedBatch_result result;
  try {
    iface_->executePreparedBatch(result.success, args.stmtId, args.paramsBatch, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.executePreparedBatch");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("executePreparedBatch", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.executePreparedBatch");
  }

  oprot->writeMessageBegin("executePreparedBatch", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.executePreparedBatch", bytes);
  }
}

void SnappyDataServiceProcessor::process_prepareAndExecute(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.prepareAndExecute", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.prepareAndExecute");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.prepareAndExecute");
  }

  SnappyDataService_prepareAndExecute_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.prepareAndExecute", bytes);
  }

  SnappyDataService_prepareAndExecute_result result;
  try {
    iface_->prepareAndExecute(result.success, args.connId, args.sql, args.paramsBatch, args.outputParams, args.attrs, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.prepareAndExecute");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("prepareAndExecute", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.prepareAndExecute");
  }

  oprot->writeMessageBegin("prepareAndExecute", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.prepareAndExecute", bytes);
  }
}

void SnappyDataServiceProcessor::process_beginTransaction(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.beginTransaction", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.beginTransaction");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.beginTransaction");
  }

  SnappyDataService_beginTransaction_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.beginTransaction", bytes);
  }

  SnappyDataService_beginTransaction_result result;
  try {
    iface_->beginTransaction(args.connId, args.isolationLevel, args.flags, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.beginTransaction");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("beginTransaction", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.beginTransaction");
  }

  oprot->writeMessageBegin("beginTransaction", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.beginTransaction", bytes);
  }
}

void SnappyDataServiceProcessor::process_setTransactionAttributes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.setTransactionAttributes", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.setTransactionAttributes");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.setTransactionAttributes");
  }

  SnappyDataService_setTransactionAttributes_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.setTransactionAttributes", bytes);
  }

  SnappyDataService_setTransactionAttributes_result result;
  try {
    iface_->setTransactionAttributes(args.connId, args.flags, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.setTransactionAttributes");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("setTransactionAttributes", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.setTransactionAttributes");
  }

  oprot->writeMessageBegin("setTransactionAttributes", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.setTransactionAttributes", bytes);
  }
}

void SnappyDataServiceProcessor::process_getTransactionAttributes(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getTransactionAttributes", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getTransactionAttributes");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getTransactionAttributes");
  }

  SnappyDataService_getTransactionAttributes_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getTransactionAttributes", bytes);
  }

  SnappyDataService_getTransactionAttributes_result result;
  try {
    iface_->getTransactionAttributes(result.success, args.connId, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getTransactionAttributes");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getTransactionAttributes", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getTransactionAttributes");
  }

  oprot->writeMessageBegin("getTransactionAttributes", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getTransactionAttributes", bytes);
  }
}

void SnappyDataServiceProcessor::process_commitTransaction(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.commitTransaction", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.commitTransaction");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.commitTransaction");
  }

  SnappyDataService_commitTransaction_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.commitTransaction", bytes);
  }

  SnappyDataService_commitTransaction_result result;
  try {
    iface_->commitTransaction(args.connId, args.startNewTransaction, args.flags, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.commitTransaction");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("commitTransaction", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.commitTransaction");
  }

  oprot->writeMessageBegin("commitTransaction", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.commitTransaction", bytes);
  }
}

void SnappyDataServiceProcessor::process_rollbackTransaction(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.rollbackTransaction", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.rollbackTransaction");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.rollbackTransaction");
  }

  SnappyDataService_rollbackTransaction_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.rollbackTransaction", bytes);
  }

  SnappyDataService_rollbackTransaction_result result;
  try {
    iface_->rollbackTransaction(args.connId, args.startNewTransaction, args.flags, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.rollbackTransaction");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("rollbackTransaction", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.rollbackTransaction");
  }

  oprot->writeMessageBegin("rollbackTransaction", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.rollbackTransaction", bytes);
  }
}

void SnappyDataServiceProcessor::process_prepareCommitTransaction(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.prepareCommitTransaction", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.prepareCommitTransaction");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.prepareCommitTransaction");
  }

  SnappyDataService_prepareCommitTransaction_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.prepareCommitTransaction", bytes);
  }

  SnappyDataService_prepareCommitTransaction_result result;
  try {
    result.success = iface_->prepareCommitTransaction(args.connId, args.flags, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.prepareCommitTransaction");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("prepareCommitTransaction", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.prepareCommitTransaction");
  }

  oprot->writeMessageBegin("prepareCommitTransaction", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.prepareCommitTransaction", bytes);
  }
}

void SnappyDataServiceProcessor::process_getNextResultSet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getNextResultSet", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getNextResultSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getNextResultSet");
  }

  SnappyDataService_getNextResultSet_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getNextResultSet", bytes);
  }

  SnappyDataService_getNextResultSet_result result;
  try {
    iface_->getNextResultSet(result.success, args.cursorId, args.otherResultSetBehaviour, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getNextResultSet");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getNextResultSet", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getNextResultSet");
  }

  oprot->writeMessageBegin("getNextResultSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getNextResultSet", bytes);
  }
}

void SnappyDataServiceProcessor::process_getBlobChunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getBlobChunk", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getBlobChunk");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getBlobChunk");
  }

  SnappyDataService_getBlobChunk_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getBlobChunk", bytes);
  }

  SnappyDataService_getBlobChunk_result result;
  try {
    iface_->getBlobChunk(result.success, args.connId, args.lobId, args.offset, args.size, args.freeLobAtEnd, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getBlobChunk");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getBlobChunk", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getBlobChunk");
  }

  oprot->writeMessageBegin("getBlobChunk", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getBlobChunk", bytes);
  }
}

void SnappyDataServiceProcessor::process_getClobChunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getClobChunk", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getClobChunk");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getClobChunk");
  }

  SnappyDataService_getClobChunk_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getClobChunk", bytes);
  }

  SnappyDataService_getClobChunk_result result;
  try {
    iface_->getClobChunk(result.success, args.connId, args.lobId, args.offset, args.size, args.freeLobAtEnd, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getClobChunk");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getClobChunk", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getClobChunk");
  }

  oprot->writeMessageBegin("getClobChunk", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getClobChunk", bytes);
  }
}

void SnappyDataServiceProcessor::process_sendBlobChunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.sendBlobChunk", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.sendBlobChunk");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.sendBlobChunk");
  }

  SnappyDataService_sendBlobChunk_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.sendBlobChunk", bytes);
  }

  SnappyDataService_sendBlobChunk_result result;
  try {
    result.success = iface_->sendBlobChunk(args.chunk, args.connId, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.sendBlobChunk");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sendBlobChunk", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.sendBlobChunk");
  }

  oprot->writeMessageBegin("sendBlobChunk", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.sendBlobChunk", bytes);
  }
}

void SnappyDataServiceProcessor::process_sendClobChunk(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.sendClobChunk", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.sendClobChunk");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.sendClobChunk");
  }

  SnappyDataService_sendClobChunk_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.sendClobChunk", bytes);
  }

  SnappyDataService_sendClobChunk_result result;
  try {
    result.success = iface_->sendClobChunk(args.chunk, args.connId, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.sendClobChunk");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("sendClobChunk", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.sendClobChunk");
  }

  oprot->writeMessageBegin("sendClobChunk", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.sendClobChunk", bytes);
  }
}

void SnappyDataServiceProcessor::process_freeLob(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.freeLob", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.freeLob");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.freeLob");
  }

  SnappyDataService_freeLob_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.freeLob", bytes);
  }

  SnappyDataService_freeLob_result result;
  try {
    iface_->freeLob(args.connId, args.lobId, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.freeLob");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("freeLob", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.freeLob");
  }

  oprot->writeMessageBegin("freeLob", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.freeLob", bytes);
  }
}

void SnappyDataServiceProcessor::process_scrollCursor(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.scrollCursor", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.scrollCursor");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.scrollCursor");
  }

  SnappyDataService_scrollCursor_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.scrollCursor", bytes);
  }

  SnappyDataService_scrollCursor_result result;
  try {
    iface_->scrollCursor(result.success, args.cursorId, args.offset, args.offsetIsAbsolute, args.fetchReverse, args.fetchSize, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.scrollCursor");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("scrollCursor", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.scrollCursor");
  }

  oprot->writeMessageBegin("scrollCursor", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.scrollCursor", bytes);
  }
}

void SnappyDataServiceProcessor::process_executeCursorUpdate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.executeCursorUpdate", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.executeCursorUpdate");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.executeCursorUpdate");
  }

  SnappyDataService_executeCursorUpdate_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.executeCursorUpdate", bytes);
  }

  SnappyDataService_executeCursorUpdate_result result;
  try {
    iface_->executeCursorUpdate(args.cursorId, args.operations, args.changedRows, args.changedColumnsList, args.changedRowIndexes, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.executeCursorUpdate");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("executeCursorUpdate", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.executeCursorUpdate");
  }

  oprot->writeMessageBegin("executeCursorUpdate", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.executeCursorUpdate", bytes);
  }
}

void SnappyDataServiceProcessor::process_getServiceMetaData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getServiceMetaData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getServiceMetaData");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getServiceMetaData");
  }

  SnappyDataService_getServiceMetaData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getServiceMetaData", bytes);
  }

  SnappyDataService_getServiceMetaData_result result;
  try {
    iface_->getServiceMetaData(result.success, args.connId, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getServiceMetaData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getServiceMetaData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getServiceMetaData");
  }

  oprot->writeMessageBegin("getServiceMetaData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getServiceMetaData", bytes);
  }
}

void SnappyDataServiceProcessor::process_getSchemaMetaData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getSchemaMetaData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getSchemaMetaData");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getSchemaMetaData");
  }

  SnappyDataService_getSchemaMetaData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getSchemaMetaData", bytes);
  }

  SnappyDataService_getSchemaMetaData_result result;
  try {
    iface_->getSchemaMetaData(result.success, args.schemaCall, args.metadataArgs);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getSchemaMetaData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getSchemaMetaData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getSchemaMetaData");
  }

  oprot->writeMessageBegin("getSchemaMetaData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getSchemaMetaData", bytes);
  }
}

void SnappyDataServiceProcessor::process_getIndexInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getIndexInfo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getIndexInfo");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getIndexInfo");
  }

  SnappyDataService_getIndexInfo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getIndexInfo", bytes);
  }

  SnappyDataService_getIndexInfo_result result;
  try {
    iface_->getIndexInfo(result.success, args.metadataArgs, args.unique, args.approximate);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getIndexInfo");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getIndexInfo", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getIndexInfo");
  }

  oprot->writeMessageBegin("getIndexInfo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getIndexInfo", bytes);
  }
}

void SnappyDataServiceProcessor::process_getUDTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getUDTs", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getUDTs");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getUDTs");
  }

  SnappyDataService_getUDTs_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getUDTs", bytes);
  }

  SnappyDataService_getUDTs_result result;
  try {
    iface_->getUDTs(result.success, args.metadataArgs, args.types);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getUDTs");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getUDTs", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getUDTs");
  }

  oprot->writeMessageBegin("getUDTs", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getUDTs", bytes);
  }
}

void SnappyDataServiceProcessor::process_getBestRowIdentifier(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.getBestRowIdentifier", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.getBestRowIdentifier");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.getBestRowIdentifier");
  }

  SnappyDataService_getBestRowIdentifier_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.getBestRowIdentifier", bytes);
  }

  SnappyDataService_getBestRowIdentifier_result result;
  try {
    iface_->getBestRowIdentifier(result.success, args.metadataArgs, args.scope, args.nullable);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.getBestRowIdentifier");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getBestRowIdentifier", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.getBestRowIdentifier");
  }

  oprot->writeMessageBegin("getBestRowIdentifier", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.getBestRowIdentifier", bytes);
  }
}

void SnappyDataServiceProcessor::process_fetchActiveConnections(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.fetchActiveConnections", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.fetchActiveConnections");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.fetchActiveConnections");
  }

  SnappyDataService_fetchActiveConnections_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.fetchActiveConnections", bytes);
  }

  SnappyDataService_fetchActiveConnections_result result;
  try {
    iface_->fetchActiveConnections(result.success, args.connId, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.fetchActiveConnections");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("fetchActiveConnections", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.fetchActiveConnections");
  }

  oprot->writeMessageBegin("fetchActiveConnections", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.fetchActiveConnections", bytes);
  }
}

void SnappyDataServiceProcessor::process_fetchActiveStatements(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.fetchActiveStatements", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.fetchActiveStatements");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.fetchActiveStatements");
  }

  SnappyDataService_fetchActiveStatements_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.fetchActiveStatements", bytes);
  }

  SnappyDataService_fetchActiveStatements_result result;
  try {
    iface_->fetchActiveStatements(result.success, args.connId, args.token);
    result.__isset.success = true;
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.fetchActiveStatements");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("fetchActiveStatements", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.fetchActiveStatements");
  }

  oprot->writeMessageBegin("fetchActiveStatements", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.fetchActiveStatements", bytes);
  }
}

void SnappyDataServiceProcessor::process_cancelStatement(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.cancelStatement", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.cancelStatement");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.cancelStatement");
  }

  SnappyDataService_cancelStatement_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.cancelStatement", bytes);
  }

  SnappyDataService_cancelStatement_result result;
  try {
    iface_->cancelStatement(args.stmtId, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.cancelStatement");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("cancelStatement", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.cancelStatement");
  }

  oprot->writeMessageBegin("cancelStatement", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.cancelStatement", bytes);
  }
}

void SnappyDataServiceProcessor::process_closeResultSet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.closeResultSet", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.closeResultSet");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.closeResultSet");
  }

  SnappyDataService_closeResultSet_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.closeResultSet", bytes);
  }

  SnappyDataService_closeResultSet_result result;
  try {
    iface_->closeResultSet(args.cursorId, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.closeResultSet");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("closeResultSet", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.closeResultSet");
  }

  oprot->writeMessageBegin("closeResultSet", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.closeResultSet", bytes);
  }
}

void SnappyDataServiceProcessor::process_closeStatement(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.closeStatement", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.closeStatement");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.closeStatement");
  }

  SnappyDataService_closeStatement_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.closeStatement", bytes);
  }

  SnappyDataService_closeStatement_result result;
  try {
    iface_->closeStatement(args.stmtId, args.token);
  } catch (SnappyException &error) {
    result.error = error;
    result.__isset.error = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.closeStatement");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("closeStatement", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "SnappyDataService.closeStatement");
  }

  oprot->writeMessageBegin("closeStatement", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "SnappyDataService.closeStatement", bytes);
  }
}

void SnappyDataServiceProcessor::process_closeConnection(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.closeConnection", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.closeConnection");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.closeConnection");
  }

  SnappyDataService_closeConnection_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.closeConnection", bytes);
  }

  try {
    iface_->closeConnection(args.connId, args.token);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.closeConnection");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "SnappyDataService.closeConnection");
  }

  return;
}

void SnappyDataServiceProcessor::process_bulkClose(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("SnappyDataService.bulkClose", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "SnappyDataService.bulkClose");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "SnappyDataService.bulkClose");
  }

  SnappyDataService_bulkClose_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "SnappyDataService.bulkClose", bytes);
  }

  try {
    iface_->bulkClose(args.entities);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "SnappyDataService.bulkClose");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "SnappyDataService.bulkClose");
  }

  return;
}

::boost::shared_ptr< ::apache::thrift::TProcessor > SnappyDataServiceProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< SnappyDataServiceIfFactory > cleanup(handlerFactory_);
  ::boost::shared_ptr< SnappyDataServiceIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::boost::shared_ptr< ::apache::thrift::TProcessor > processor(new SnappyDataServiceProcessor(handler));
  return processor;
}

}}} // namespace

